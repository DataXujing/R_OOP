[
["index.html", "R语言面向对象编程 写在书前", " R语言面向对象编程 徐静 2018-08-05 写在书前 为了理解R中的计算，下面的两个口号是有用的 一切皆是对象 一切皆是函数调用 from John Chambers 1年半之前就有计划整理一份R语言面向对象编程的详细文档，今天终于有了一点眉目。 从2016年初开始研究R语言中的一些黑魔法，一直在尝试R语言的面向对象的编程，本人经历了Java和Python面向对象编程的洗礼，加深了对R语言面向对象编程的深入理解。本电子书是我在应用Java和Python面向对象编程后，对R语言面向对象编程的进一步理解的学习文档，希望对R社区的小伙伴有帮助。 所有代码本人均在Ubuntu 16.04 LTS和CentOs6.5下尝试正常通过。 "],
["e5a3b0e6988e.html", "声明", " 声明 关于我 徐静： 硕士研究生, 目前的研究兴趣主要包括：数理统计，统计机器学习，深度学习，网络爬虫，前端可视化，R语言和Python语言的超级粉丝，多个R包和Python模块的作者，现在正逐步向Java迁移。 Graduate students,the current research interests include: mathematical statistics, statistical machine learning, deep learning, web crawler, front-end visualization. He is a super fan of R and Python, and the author of several R packages and Python modules, and now gradually migrating to Java. 声明 本书内容并非笔者原创，而是对参考文献[1-3]学习之后的整理再现，特此说明。本电子书完全免费，但转载或用于其他商业用途请说明来源：https://dataxujing.github.io/R_oop/ 学R不思则罔，思R不学则殆。 "],
["ch1.html", "第 1 章 R语言编程风格指南 1.1 符号和名字 1.2 语法 1.3 结构", " 第 1 章 R语言编程风格指南 好的编程风格(程序编写格式)就像正确使用标点符号。没有他也可以，但是他会让你编写的程序易于理解。建议参考Google R语言编程风格指南(https://nanx.me/rstyle/)。虽然你的代码只有一个作者，但通常有许多读者，所以好的风格是很重要的。当你和他人合作编写代码时，尤其要注意编程风格，但是要注意没有一种风格说是最优的，但是你们需要统一。YiHuiXie编写的formatR添加包使得整理格式混乱的代码变得容易，但是不能解决一切问题。 1.1 符号和名字 1.1.1 文件名 文件名应该有一定的意义，并且以.R结尾 #good fit-model.R utility-function.R #bad foo.r stuff.r 如果文件需要按照顺序执行，那么做好在命名时加上数字前缀 0-download.R 1-parse.R 2-explore.R 1.1.2 对象名 在计算机科学中有两件非常难的事情，缓存失效和对象命名。变量和函数名应该是小写字母，使用下划线(_)将名字中的单词分开。通常变量名应该是名词，函数名应该是动词。追求简洁而有意义的名字。 #good day_one day_1 #bad first_day_of_month DayOne dayone djm1 1.2 语法 1.2.1 空格 所有中缀运算符(=,+,-,&lt;-等)的两边使用空格。要在逗号的后面而非前面加上空格 #good average &lt;- mean(feet / 12 + inches, na.rm = TRUE) #bad average&lt;-mean(feet/12+inches,na.rm=TRUE) 这个规则有个小小的例外，:,::,:::的两边不需要空格 #good x &lt;- 1:10 base::get #bad x &lt;- 1:10 base :: get 在小括号的左边放置一个空格，函数调用例外 #good if (debug) do(x) plot(x, y) #bad if(debug)do(x) plot (x, y) 如果是为了对齐等号或赋值符号，也可以使用额外的空格 list( total = a + b + c, mean = (a + b + c) / n ) 小括号或中括号内代码的两侧不需要放置空格(除非有逗号，要在逗号的后边放置空格) #good if (debug) do(x) diamonds[5, ] #bad if ( debug ) do(x) x[1,] x[1, ] 1.2.2 大括号 大括号的左半边不能独占一行，它后边也应该新起一行，右半边应该独占一行或它的后边是else。对大括号中的代码要缩进 #good if (y &lt; 0 &amp;&amp; debug) { message(&quot;Y is negative&quot;) } if (y == 0) { log(x) } else { y^x } #bad if (y &lt;= 0 &amp;&amp; debug) message(&quot;Y is negative&quot;) if (y == 0) { log(x) } else { y^x } 可以在同一行上留下非常短的语句： if (y &lt; 0 &amp;&amp; debug) message(&quot;Y is message&quot;) 1.2.3 行的长度 努力使每行代码不超过80个字符，如果你的代码超过了这个长度，这说明你应该将一些功能打包成独立的函数。 1.2.4 缩进 缩进代码使用两个空格，不要使用制表符(tab)或者制表符加空格。唯一的例外是，如果一个函数定义跨越了很多行。这种情况下，第二行要缩进到定义开始的地方: long_function_name &lt;- function (a = &quot;a long argument&quot;, b = &quot;another argument&quot;, c = &quot;another long argument&quot;) { # As usual code is idented by two spaces. } 1.2.5 赋值 赋值时使用 &lt;- 而不是 =。 #good x &lt;- 5 #bad x = 5 1.3 结构 注释指南 对代码进行注释，每行的注释都应该以注释符和一个空格开始: #。 注释应该解释为什么。而不是是什么。 使用由-和=构成的注释行将文件分割成容易理解的段落(块) # Load Data -------------------------------------------- # Plot Data -------------------------------------------- 好的程序猿一定有自己的编程风格，并且在团队中能够快速的调整使得编程风格达成一致，所以与其他人合作意味着你可能需要对自己喜好的某些风格做出让步。 "],
["ch2.html", "第 2 章 R语言面向对象编程指南 2.1 什么是面向对象 2.2 R为什么要进行面向对象的编程 2.3 R的面向对象编程", " 第 2 章 R语言面向对象编程指南 面向对象是一种对世界理解和抽象的方法，当代码复杂度增加难以维护的时候，面向对象就会显得很重要，我经历过Java和Python两种语言从面向过程到面向对象的改造，对R的面向对象的编程也早有些研究但开始的时候并不是那么的透彻。随着大数据时代AI时代的来临，R将走向大规模的企业级应用，因此面向对象的编程方式也会将成为R语言的一种非常重要的趋势，并且多位R语言大神，像Hadley Wickham等在R包开发中早就引入了面向对象的编程方式，R语言的发展也势必会面向对象。 2.1 什么是面向对象 学过计算机编程基础的人都知道，计算机是通过接受一些逻辑指令，然后翻译成机器码，进而控制CPU的电路，从而实现我们能看到的所有操作。无论是何种计算机编程语言，都可以认为是计算机和人类沟通的翻译，将一般人能懂的计算机语言翻译成计算机能懂的机器语言。 简单的理解，有的语言比较接近机器的习惯，机器执行起来会更有效率；有的语言比较接近人的习惯，人类设计起来会更容易。面向对象的思想就属于第二种情况。 人的思维方式和计算机是不同的，计算机习惯按照顺序执行不同的指令，依据严格的逻辑进行不同的行为，而人类处理问题的方式通常是先对问题进行分析，然后调动不同的资源做不同的事情。 喜欢历史故事的朋友都知道诸葛亮打仗和刘邦打仗的区别。诸葛亮会命令某人埋伏，某人放火，某人举旗，某人不战而退，某人斜刺里杀出，每个人听到命令都不知道最后会发生什么。直到最后敌军被一条龙的歼灭后，得胜归来的将军们对诸葛亮佩服的五体投地。而刘邦打仗的故事远没有那么精彩，事情来了该让韩信做的交给韩信，该让萧何做的交给萧何。 如何像刘邦一样的写程序，这就是面向对象的程序设计。韩信，萧何这些人都可以认为是对象，我们只需要知道他们有什么特点，根据问题的不同派不同的人去做就可以了，而诸葛亮关注的是具体流程，至于是关羽去放火还是张飞去放火反而不重要了，这就是过程式的编程思想。 面向对象的程序设计在运行效率上可能没有优势，但是节约了开发者和设计者的时间，在R语言和S语言上这一点完全一致，S语言很重要的设计理念是“人的时间远比机器的时间宝贵”。对各种模型和算法的封装及重用与面向对象的编程目的是相同的。 在面向对象的程序设计中，对象(object)是最基本的元素，不过对象指的是具体的实例，在对象之上还有一个类(class)的概念。这里的类和R中的类的概念没有任何不同，都是指某一种抽象对象的类型(和R中的type不同,type指的是在内存存储方面的类型)。 比如说“马”就是一个类，随便牵来一匹白马或红马都属于马这个范畴，但都和马这个东西不一样，如果牵来的白马是刘备的的卢马，红马是关羽的赤兔马，那么这两匹马就是对象。所以类是抽象的概念，对象是类的具体实例。我们直接操作的是对象，但是需要定义的是类。 用面向对象的专业术语来说，马就是一个“类”，白马和红马是马的“子类”，的卢马是白马实例化的对象，也是马实例化的对象。 一般来说类包含属性和方法，属性指的是类具有的某些信息，在计算机程序中通常是变量，方法指的是类进行的操作，在计算机程序中相当于函数。 并不是具有了类和对象的概念后就成了面向对象的程序设计，一般来说还得具备三个特性：封装、继承和多态。 封装指的是隐藏对象的实现细节，仅对外公开接口，每个对象都可以独立的完成一定的功能，不需要和其他对象有过多的交互，所有的数据交换都通过接口来处理，专业术语是降低系统的“耦合度”。 比如说马这种交通工具就是一个封装的很好的类，具有颜色、体重等属性，具有载人、奔跑等方法。用的时候把马牵出来，通过缰绳和马鞭这几个接口来控制动作。 继承是一个类可以继承另一个类的各种属性及方法，重写或增加某些属性和方法，被继承的类称为“父类”，继承了父类的类的称为“子类”。通过继承可以重写父类方法或增加额外功能，注意R语言像Python一样支持多重继承，Java不支持多继承，但是有其他办法实现。当然除了继承也可以组合类。 多态可以说是面向对象的程序设计中最关键的特性，如果某种语言支持以上所有特性但是不支持多态，我们称其为“基于对象”而不是面向对象，所谓多态简单来说就是希望能用相同的命令作用于不同的类，根据类的不同产生不同的结果。 #作用在数值数据 summary(rnorm(10)) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## -1.6474 -1.0625 -0.7016 -0.4267 -0.1363 2.1232 #作用在Model上 summary(lm(rnorm(10)~rnorm(10))) ## ## Call: ## lm(formula = rnorm(10) ~ rnorm(10)) ## ## Residuals: ## Min 1Q Median 3Q Max ## -1.53698 -0.20735 -0.01946 0.49899 1.49425 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 0.5178 0.2721 1.903 0.0894 . ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.8604 on 9 degrees of freedom 2.2 R为什么要进行面向对象的编程 R主要面向统计计算，而且代码量一般不会很大，几十行，几百行，使用面向过程的编程方式就可以很好的完成编程任务。在R中流传着一个深入人心的说法“万物皆对象”，另一方面，R是一种函数式的语言，与面向对象的程序设计存在着天然的差异，实际上这两个对象的描述的含义是不同的。“万物皆对象”是指R的基本数据结构的地位都是相同的，任何东西包括函数都可以认为是对象，都能作为参数传入到函数中。而“面向对象”指的是一种编程泛型，已经成为一个专有的名词。 但是随着R语言在工业界的火热，伴随着越来越多的工程背景的人的加入，R语言开始向更多领域发展，会有越来越难以维护的海量代码项目，所以必须使用面向对象的编程思想，此外如果你开发一些R包需要对特殊的对象重定义S3(下一章会讲)的方法，需要对大量程序代码最大化的重用和封装(S4(后面会讲到))，那么这时候你同样需要用到R语言的面向对象的编程。 一句话，随着R语言的发展，R面向对象编程一定是一个大的趋势。 2.3 R的面向对象编程 R的面向对象是基于泛型函数(generic function)的，而不是基于类层次结构，接下来我们从面向对象的3个特征入手，分别用R语言进行实现。 封装 # 定义teacher对象和行为 teacher &lt;- function(x,...) UseMethod(&quot;teacher&quot;) teacher.lecture &lt;- function(x,...) print(&quot;上课&quot;) teacher.assignment &lt;- function(x,...) print(&quot;布置作业&quot;) teacher.correcting &lt;- function(x,...) print(&quot;批改作业&quot;) teacher.default &lt;- function(x,...) print(&quot;你不是teacher&quot;) # 定义同学对象和行为 student &lt;- function(x,...) UseMethod(&quot;student&quot;) student.attend &lt;- function(x,...) print(&quot;听课&quot;) student.homework &lt;- function(x,...) print(&quot;写作业&quot;) student.exam &lt;- function(x,...) print(&quot;考试&quot;) student.default &lt;- function(x,...) print(&quot;你不是student&quot;) #定义两个变量，a老师和b同学 a &lt;- &#39;teacher&#39; b &lt;- &#39;student&#39; # 给老师变量设置行为 attr(a,&quot;class&quot;) &lt;- &#39;lecture&#39; # 执行老师的行为 teacher(a) ## [1] &quot;上课&quot; attr(b,&#39;class&#39;) &lt;- &#39;attend&#39; student(b) ## [1] &quot;听课&quot; attr(a,&#39;class&#39;) &lt;- &#39;assignment&#39; teacher(a) ## [1] &quot;布置作业&quot; 继承 # 给同学对象增加新的行为 student.correcting &lt;- function(x) print(&quot;帮助老师批改作业&quot;) # 辅助变量用于设置初始值 char0 = character(0) #实现继承关系 create &lt;- function(classes=char0,parents=char0){ mro &lt;- c(classes) for(name in parents){ mro &lt;- c(mro,name) ancestors &lt;- attr(get(name),&#39;type&#39;) mro &lt;- c(mro,ancestors(ancestors != name)) } return(mro) } # 定义构造函数，创建对象 NewInstance &lt;- function(value=0,classes=char0,parents=char0) { obj &lt;- value attr(obj,&#39;type&#39;) &lt;- create(classes,parents) attr(obj,&quot;class&quot;) &lt;- c(&#39;homework&#39;,&#39;correcting&#39;,&#39;exam&#39;) return(obj) } # 创建对象实例 StudentObj &lt;- NewInstance() # 创建子对象实例 s1 &lt;- NewInstance(&quot;普通同学&quot;,classes = &#39;normal&#39;,parents = &quot;StudentObj&quot;) s2 &lt;- NewInstance(&#39;课代表&#39;,classes=&#39;leader&#39;,parents=&#39;StudentObj&#39;) # 给课代表，增加批改作业行为 attr(s2,&#39;class&#39;) &lt;- c(attr(s2,&#39;class&#39;),&#39;correcting&#39;) s1 s2 多态 # 创建优等生和次等生，两个实例 e1 &lt;- NewInstance(&quot;优等生&quot;,classes=&#39;excellent&#39;,parents=&#39;StudentObj&#39;) e2 &lt;- NewInstance(&quot;次等生&quot;,classes=&#39;poor&#39;,parents=&#39;StudentObj&#39;) student.exam &lt;- function(x,score){ p &lt;- &#39;考试&#39; if(score&gt;85) print(paste(p,&quot;优秀&quot;)) if(score&lt;70) print(paste(p,&quot;及格&quot;)) } # 执行优等生的考试行为，并输入分数为90 attr(e1,&#39;class&#39;) &lt;- &#39;exam&#39; stuent(e1,90) [1] “考试优秀&quot; attr(e2,&#39;class&#39;) &lt;- &#39;exam&#39; student(e2,66) [1] ”考试及格&quot; 通过R语言的面向对象的反省函数，我们就可以实现面向对象的编程。 "],
["S3.html", "第 3 章 基于S3的面向对象编程 3.1 S3对象的介绍 3.2 创建S3对象 3.3 泛型函数和方法调用 3.4 查看S3对象的函数 3.5 S3对象的继承关系 3.6 S3对象的缺点 3.7 S3对象的使用", " 第 3 章 基于S3的面向对象编程 对于R语言的面向对象编程，不同于其他编程语言，R语言提供了3种底层对象类型，一种是S3类型，一种是S4类型，还有一种是RC类型。 S3对象简答，具有动态性，结构化特征不明显，S4对象结构化。功能强大，RC对象是R2.12版本后使用的新类型，用于解决S3,S4很难是想的对象。 本章主要介绍S3的面向对象编程的细节 3.1 S3对象的介绍 在R语言中，基于S3对象的面向对象编程，是一种基于泛型函数的实现方式。泛型函数是一种特殊的函数，根据传入对象的类型决定调用那个具体的方法。基于S3对象实现面向对象编程，不同其他语言的面型对象编程，是一种动态函数调用的模拟实现。S3对象被广泛应用于R的早期的开发包中。 3.2 创建S3对象 注意：本文会用到pryr,为了方便我们检查对象的类型，引入pryr包作为辅助工具。 library(pryr) #通过变量创建S3对象 x &lt;- 1 attr(x,&#39;class&#39;) &lt;- &#39;foo&#39; x ## [1] 1 ## attr(,&quot;class&quot;) ## [1] &quot;foo&quot; attr(x,&quot;class&quot;) ## [1] &quot;foo&quot; class(x) ## [1] &quot;foo&quot; #用pryr包的otype函数,检查x的类型 otype(x) ## [1] &quot;S3&quot; 通过structure()函数创建S3对象 y &lt;- structure(2,class=&quot;foo&quot;) y ## [1] 2 ## attr(,&quot;class&quot;) ## [1] &quot;foo&quot; attr(y,&quot;class&quot;) ## [1] &quot;foo&quot; class(y) ## [1] &quot;foo&quot; otype(y) ## [1] &quot;S3&quot; 创建一个多类型的S3对象，S3独享没有明确结构关系，一个S3对象可以有多个类型，S3对象的class属性可以是一个响亮，包括多种类型 x &lt;- 1 attr(x,&quot;class&quot;) &lt;- c(&quot;foo&quot;,&quot;bar&quot;) class(x) ## [1] &quot;foo&quot; &quot;bar&quot; otype(x) ## [1] &quot;S3&quot; 3.3 泛型函数和方法调用 对于S3对象的使用，通常用UseMethod()函数来定义一个泛型函数的名称，通过传入参数的class属性，来确定方法调用。 定义一个teacher的泛型函数 用UseMethod()定义teacher泛型函数 用teacher.xxx的语法格式定义teacher对象的行为 其中teacher.default是默认行为 # 用UseMethod()定义teacher泛型函数 teacher &lt;- function(x,...) UseMethod(&quot;teacher&quot;) # 用pryr包中ftype()函数，检查teacher类型 ftype(teacher) [1] &quot;s3&quot; &quot;generic&quot; # 定义teacher内部函数 teacher.lecture &lt;- function(x,...) print(&quot;讲课&quot;) teacher.assignment &lt;- function(x,...) print(&quot;布置作业&quot;) teacher.correcting &lt;- function(x,...) print(&quot;批改作业&quot;) teacher.default &lt;- function(x,...) print(&quot;你不是teacher&quot;) 方法调用通过传入参数的class属性，来确定不同方法调用 定义一个变量a，并设置a的class属性为lecture 把变量a传入到teacher泛型函数中 函数teacher.lecture()函数的行为被调用 a &lt;- &quot;teacher&quot; # 给老师变量设置行为 attr(a,&quot;class&quot;) &lt;- &#39;lecture&#39; # 执行老师的行为 teacher(a) [1] “讲课” 当然我们可以直接调用teacher中定义的行为，如果这样做就失去了面向对象封装的意义 teacher.lecture() [1] &quot;讲课&quot; teacher.lecture(a) [1] &quot;讲课&quot; teacher() [1] &quot;你不是teacher&quot; 3.4 查看S3对象的函数 当我们使用S3队形进行面向对象封装后，可以使用methods()函数来查看S3对象中的定义的内部行为函数。 # 查看teacher对象 &gt; teacher function(x,...) Usemethod(&quot;teacher&quot;) # 查看teacher对象的内部函数 &gt; methods(teacher) [1] teacher.assignment teacher.correcting teacher.default teacher.lecture #通过methods()的generic.function参数，来匹配泛型函数名字 &gt; methods(generic.function = predict) [1] predict.ar* ...... 通过methods()的class参数，来匹配类的名字 &gt; methods(class=lm) [1]add1.lm* ...... 用getAnywhere()函数,查看所有函数 #查看teacher.lecture函数 &gt;getAnywhere(teacher.lecture) 使用getS3method()函数，也同样可以查看不可见的函数 # getS3method()函数查找predict.ppr get时method(&quot;predict&quot;,&quot;ppr&quot;) 3.5 S3对象的继承关系 S3独享有一种非常简单的继承方式，用NextMethod()函数来实现。 定义一个node泛型函数 &gt; node &lt;- function(x) UseMethod(&quot;node&quot;,x) &gt; node.default &lt;- function(x) &quot;Default node&quot; #father函数 &gt; node.father &lt;- function(x) c(&quot;father&quot;) # son函数，通过NextMethod()函数只想father函数 &gt; node.son &lt;- function(x) c(&#39;son&#39;,NextMethod()) #定义n1 &gt; n1 &lt;- structure(1,class=c(&quot;father&quot;)) # 在node函数中传入n1,执行node.father()函数 &gt; node(n1) [1] &quot;father&quot; # 定义n2，设置class属性为两个 &gt; n2 &lt;- structure(1,class=c(&quot;son&quot;,&quot;father&quot;)) # 在node函数中传入n2,执行node.son()函数和node.father()函数 &gt; node(n2) [1] &quot;son&quot; &quot;father&quot; 通过对node()函数传入n2的参数，node.son()先被执行，然后通过NextMethod()函数继续执行了node.father()函数。这样其实就模拟了，子函数调用父函数的过程，实现了面向对象编程中的继承。 3.6 S3对象的缺点 从上面S3对象的介绍上来看，S3对象并不是完全的面向对象实现，而是一种通过泛型函数模拟的面向对象的实现。 S3用起来简单，但在实际的面向对象编程的过程中，当对象关系有一定的复杂度，S3对象所表达的意义就变得不太清楚 S3封装的内部函数，可以绕过泛型函数的检查，以直接被调用 S3参数的class属性，可以被任意设置，没有预处理的检查 S3参数，只能通过调用class属性进行函数调用，其他属性则不会被class()函数执行 S3参数的class属性有多个值时，调用时会被按照程序赋值顺序来调用第一个合法的函数 所以，S3只是R语言面向对象的一种简单的实现。 3.7 S3对象的使用 S3对象系统，被广泛的应用于R语言早期的开发中。在base包中，就有很多S3对象 base包的S3对象 # mean 函数 mean ## function (x, ...) ## UseMethod(&quot;mean&quot;) ## &lt;bytecode: 0x0000000017826c10&gt; ## &lt;environment: namespace:base&gt; ftype(mean) ## [1] &quot;s3&quot; &quot;generic&quot; # t函数 ftype(t) ## [1] &quot;s3&quot; &quot;generic&quot; # plot函数 ftype(plot) ## [1] &quot;s3&quot; &quot;generic&quot; 自定义S3对象 # 定义数字变量a a &lt;- 1 # 变量a的class为number class(a) ## [1] &quot;numeric&quot; # 定义泛型函数f1 f1 &lt;- function(x){ a &lt;-2 UseMethod(&quot;f1&quot;) } # 定义f1的内部函数 f1.numeric &lt;- function(x) a # 给f1()传入变量a f1(a) ## [1] 2 # 给f1()传入99 f1(99) ## [1] 2 # 定义f1内部函数 f1.character &lt;- function(x) paste(&quot;char&quot;,x) # 给f1()传入字符a f1(&quot;a&quot;) ## [1] &quot;char a&quot; 这样，我们就对S3对象系统有了一个全面认识，开始R语言的面向对象编程之路。 "],
["S4.html", "第 4 章 基于S4的面向对象编程 4.1 S4对象介绍 4.2 创建S4对象 4.3 访问对象的属性 4.4 S4的泛型函数 4.5 查看S4对象的函数 4.6 S4对象的使用", " 第 4 章 基于S4的面向对象编程 S4对象系统具有明显的结构化特征，更适合面向对象的程序设计。Bioconductor社区以S4对象作为基础框架，只接受S4定义的R包。 4.1 S4对象介绍 S4对象系统是一种标准的R语言面向对象实现方式，S4对象有明确的类定义，参数定义，参数检查，继承关系，实例化等的面向对象系统的特征。 4.2 创建S4对象 使用辅助的pryr包 # 加载pryr包 library(pryr) 4.2.1 如何创建S4对象? 由于S4对象是标准的面向对象实现方式，有专门的类定义函数setClass()和类的实例化函数new()，我们看一下setClass()和new()是如何工作的。 setClass() setClass(class,representation,prototype,contains=character(), validity,access,where,version,sealed,package, S3methods=FALSE,slots) 参数列表： Class:定义类名 slots:定义属性和属性类型 prototype:定义属性的默认值 contains=character():定义父类，继承关系 validity:定义属性的类型检查 where:定义存储空间 sealed:如果设置TRUE,则同名类不能再次定义 package:定义所属的包 S3methods:R3.0.0后不建议使用 representation:R3.0.0后不建议使用 access:R3.0.0后不建议使用 version:R3.0.0后不建议使用 4.2.2 创建一个S4对象实例 # 定义一个S4对象 setClass(&quot;Person&quot;,slots=list(name=&quot;character&quot;,age=&quot;numeric&quot;)) # 实例化一个Person对象 father &lt;- new(&quot;Person&quot;,name=&quot;F&quot;,age=44) # 查看father对象，有两个属性name和age father ## An object of class &quot;Person&quot; ## Slot &quot;name&quot;: ## [1] &quot;F&quot; ## ## Slot &quot;age&quot;: ## [1] 44 # 查看father对象类型为Person class(father) ## [1] &quot;Person&quot; ## attr(,&quot;package&quot;) ## [1] &quot;.GlobalEnv&quot; # 查看father对象为S4的对象 otype(father) ## [1] &quot;S4&quot; 4.2.3 创建一个有继承关系的S4对象 # 创建一个S4对象Person setClass(&quot;Person&quot;,slots=list(name=&quot;character&quot;,age=&quot;numeric&quot;)) # 创建Person的子类 setClass(&quot;Son&quot;,slots=list(father=&quot;Person&quot;,mother=&quot;Person&quot;),contains = &quot;Person&quot;) # 实例化Person对象 father &lt;- new(&quot;Person&quot;,name=&quot;F&quot;,age=44) mother &lt;- new(&quot;Person&quot;,name=&quot;M&quot;,age=39) # 实例化一个Son对象 son &lt;- new(&quot;Son&quot;,name=&quot;S&quot;,age=16,father=father,mother=mother) # 查看son对象的name属性 son@name ## [1] &quot;S&quot; # 查看son对象的age属性 son@age ## [1] 16 # 查看son对象的father属性 son@father ## An object of class &quot;Person&quot; ## Slot &quot;name&quot;: ## [1] &quot;F&quot; ## ## Slot &quot;age&quot;: ## [1] 44 # 查看son对象的mother属性 son@mother ## An object of class &quot;Person&quot; ## Slot &quot;name&quot;: ## [1] &quot;M&quot; ## ## Slot &quot;age&quot;: ## [1] 39 # 查看son类型 otype(son) ## [1] &quot;S4&quot; # 查看son@name的属性 otype(son@name) ## [1] &quot;base&quot; # 查看son@mother的属性 otype(son@mother) ## [1] &quot;S4&quot; # 用isS4()检查S4对象的类型 isS4(son) ## [1] TRUE isS4(son@name) ## [1] FALSE isS4(son@mother) ## [1] TRUE 4.2.4 S4对象的默认值 setClass(&quot;Person&quot;,slots=list(name=&quot;character&quot;,age=&quot;numeric&quot;)) # 属性age为空 a &lt;- new(&quot;Person&quot;,name=&quot;a&quot;) a ## An object of class &quot;Person&quot; ## Slot &quot;name&quot;: ## [1] &quot;a&quot; ## ## Slot &quot;age&quot;: ## numeric(0) # 设置属性age的默认值为20 setClass(&quot;Person&quot;,slots=list(name=&quot;character&quot;,age=&quot;numeric&quot;),prototype=list(age=20)) # 初始化b对象 b &lt;- new(&quot;Person&quot;,name=&quot;b&quot;) # 属性age的默认值是20 b ## An object of class &quot;Person&quot; ## Slot &quot;name&quot;: ## [1] &quot;b&quot; ## ## Slot &quot;age&quot;: ## [1] 20 4.2.5 S4对象的类型检查 setClass(&quot;Person&quot;,slots=list(name=&quot;character&quot;,age=&quot;numeric&quot;)) #传入错误age类型 bad &lt;- new(&quot;Person&quot;,name=&quot;bad&quot;,age=&quot;abc&quot;) ### Error in validObject(.Object) : 类别为“Person”的对象不对: invalid object for slot &quot;age&quot; in class &quot;Person&quot;: got class &quot;character&quot;, should be or extend class &quot;numeric&quot; # 设置age的非负检查 setValidity(&quot;Person&quot;,function(object){ if(object@age &lt;= 0) stop(&quot;Age is negative.&quot;) }) # 传入小于0的年龄 bad2 &lt;- new(&quot;Person&quot;,name=&quot;bad&quot;,age=-1) ### Error in validityMethod(object) : Age is negative. 4.2.6 从一个已经实例化的对象中创建新对象 S4对象,还支持从一个已经实例化的对象中创建新对象，创建时可以覆盖旧对象的值 setClass(&quot;Person&quot;,slots=list(name=&quot;character&quot;,age=&quot;numeric&quot;)) # 创建一个对象实例n1 n1 &lt;- new(&quot;Person&quot;,name=&quot;n1&quot;,age=19) n1 ## An object of class &quot;Person&quot; ## Slot &quot;name&quot;: ## [1] &quot;n1&quot; ## ## Slot &quot;age&quot;: ## [1] 19 # 从实例n1中，创建实例n2，并修改name的属性值 n2 &lt;- initialize(n1,name=&quot;n2&quot;) n2 ## An object of class &quot;Person&quot; ## Slot &quot;name&quot;: ## [1] &quot;n2&quot; ## ## Slot &quot;age&quot;: ## [1] 19 4.3 访问对象的属性 在S3对象中，一般我使用$来访问一个对象的属性，但在S4对象中，我们只能用@来访问一个对象的属性。 setClass(&quot;Person&quot;,slots=list(name=&quot;character&quot;,age=&quot;numeric&quot;)) a &lt;- new(&quot;Person&quot;,name=&quot;a&quot;) # 访问S4对象的属性 a@name ## [1] &quot;a&quot; slot(a,&quot;name&quot;) ## [1] &quot;a&quot; # 错误的访问 #a$name #a[1] 4.4 S4的泛型函数 S4的泛型函数实现有别于S3的实现，S4分离了方法的定义和实现，如在其他语言中我们常说的接口和实现分离。通过setGeneric()来定义接口，通过setMethod()来定义现实类。这样可以让S4对象系统，更符合面向对象的特征。 普通函数的定义和调用 work &lt;- function(x) cat(x,&quot;is working&quot;) work(&quot;Conan&quot;) ## Conan is working 让我们看看如何用R分离接口和实现 # 定义Person对象 setClass(&quot;Person&quot;,slots=list(name=&quot;character&quot;,age=&quot;numeric&quot;)) # 定义泛型函数work即接口 setGeneric(&quot;work&quot;,function(object) standardGeneric(&quot;work&quot;)) ## [1] &quot;work&quot; # 定义work的实现，并指定参数类型为Person对象 setMethod(&quot;work&quot;,signature(object=&quot;Person&quot;),function(object) cat(object@name,&quot;is working&quot;)) ## [1] &quot;work&quot; # 创建一个Person对象a a &lt;- new(&quot;Person&quot;,name=&quot;Conan&quot;,age=16) # 把对象a传入work函数 work(a) ## Conan is working 通过S4对象系统，把原来的函数定义和调用2步完成的分成4步。 定义数据对象类型 定义接口函数 定义实现函数 把数据对象以参数传入到接口函数，执行实现函数 通过S4对象系统，是一个结构化的，完整的面向对象的实现。 4.5 查看S4对象的函数 当我们使用S4对象进行面向对象封装后，我们还需要能查看到S4对象的定义和函数定义，还是以上街中Person和work的例子 library(pryr) # 检查work的类型 ftype(work) # 直接查看work函数 work # 查看work函数的显示定义 showMethod(work) # 查看Person对象的work函数现实 getMethod(&quot;work&quot;,&quot;Person&quot;) # 检查Person对象有没有work函数 existMethod(&quot;work&quot;,&quot;Person&quot;) hasMethod(&quot;work&quot;,&quot;Person&quot;) 4.6 S4对象的使用 下面我们用S4对象那个实现一个具体的例子。 4.6.1 任务1：定义一个图形库的数据结构和计算函数 假设Shape为图形的基类，包括圆形(Circle)和椭圆形(Ellipse)，并计算出他们的面积(area)和周长(circum) 定义图形库的数据结构 定义圆形的数据结构，并计算面积和周长 定义椭圆形的数据结构，并计算面积和周长 定义基类Shape和圆形类Circle # 定义基类Shape setClass(&quot;Shape&quot;,slots=list(name=&quot;character&quot;)) # 定义圆形类，并继承shape,属性radius默认为1 setClass(&quot;Circle&quot;,contains = &quot;Shape&quot;,slots=list(radius=&quot;numeric&quot;),prototype=list(radius=1)) # 验正radius属性值要大于等于0 setValidity(&quot;Circle&quot;,function(object){ if(object@radius &lt;= 0) stop(&quot;Radius is negative&quot;) }) ## Class &quot;Circle&quot; [in &quot;.GlobalEnv&quot;] ## ## Slots: ## ## Name: radius name ## Class: numeric character ## ## Extends: &quot;Shape&quot; # 创建两个圆形实例 c1 &lt;- new(&quot;Circle&quot;,name=&quot;c1&quot;) c2 &lt;- new (&quot;Circle&quot;,name=&quot;c2&quot;,radius=5) 定义计算面积的接口和实现 setGeneric(&quot;area&quot;,function(obj,...){ standardGeneric(&quot;area&quot;) }) ## [1] &quot;area&quot; # 计算面积的函数实现 setMethod(&quot;area&quot;,&quot;Circle&quot;,function(obj,...){ print(&quot;Area Circle Method&quot;) pi*obj@radius^2 }) ## [1] &quot;area&quot; # 分别计算c1和c2的两个圆形的面积 area(c1) ## [1] &quot;Area Circle Method&quot; ## [1] 3.141593 area(c2) ## [1] &quot;Area Circle Method&quot; ## [1] 78.53982 定义计算周长的接口和实现 # 计算周长泛型函数接口 setGeneric(&quot;circum&quot;,function(obj,...){ standardGeneric(&quot;circum&quot;) }) ## [1] &quot;circum&quot; # 计算周长的函数实现 setMethod(&quot;circum&quot;,&quot;Circle&quot;,function(obj,...){ 2*pi*obj@radius }) ## [1] &quot;circum&quot; # 分别计算c1和c2的周长 circum(c1) ## [1] 6.283185 circum(c2) ## [1] 31.41593 上面代码，我们实现了圆形的定义，下面我们实现椭圆形 # 定义椭圆形的类，继承Shape,radius参数默认值为c(1,1)# 分别表示椭圆形的常半径和短半径 setClass(&quot;Ellipse&quot;,contains = &quot;Shape&quot;,slots=list(radius=&quot;numeric&quot;),prototype = list(radius=c(1,1))) # 验证radius参数 setValidity(&quot;Ellipse&quot;,function(object){ if(length(object@radius)!=2) stop(&quot;It&#39;s note Ellipse&quot;) if(length(which(object@radius&lt;=0))&gt;0) stop(&quot;Radius is negative&quot;) }) ## Class &quot;Ellipse&quot; [in &quot;.GlobalEnv&quot;] ## ## Slots: ## ## Name: radius name ## Class: numeric character ## ## Extends: &quot;Shape&quot; # 创建两个椭圆形实例e1,e2 e1 &lt;- new(&quot;Ellipse&quot;,name=&quot;e1&quot;) e2 &lt;- new(&quot;Ellipse&quot;,name=&quot;e2&quot;,radius=c(5,1)) # 计算椭圆形面积的函数的实现 setMethod(&quot;area&quot;,&#39;Ellipse&#39;,function(obj,...){ print(&quot;Area Ellipse Method&quot;) pi*prod(obj@radius) }) ## [1] &quot;area&quot; # 计算e1,e2的面积 area(e1) ## [1] &quot;Area Ellipse Method&quot; ## [1] 3.141593 area(e2) ## [1] &quot;Area Ellipse Method&quot; ## [1] 15.70796 # 计算椭圆形周长的函数实现 setMethod(&quot;circum&quot;,&quot;Ellipse&quot;,function(obj,...){ cat(&quot;Ellipse Circum:\\n&quot;) 2*pi*sqrt((obj@radius[1]^2+obj@radius[2]^2)/2) }) ## [1] &quot;circum&quot; # 计算e1,e2周长 circum(e1) ## Ellipse Circum: ## [1] 6.283185 circum(e2) ## Ellipse Circum: ## [1] 22.65435 4.6.2 任务2：重构圆形和椭圆形的设计 上一步，我们已经完成了圆形和椭圆形的数据结构定义，以及计算面积和周长的方法实现。不知大家有没有发现，圆形是椭圆的一个特例吗？当椭圆形的长轴和短轴相等时，形成的图形为圆形。椭圆是圆形的父类，而圆形是椭圆形的子类。 # 基类Shape setClass(&quot;Shape&quot;,slots=list(name=&quot;character&quot;,shape=&quot;character&quot;)) # Ellipse继承Shape setClass(&quot;Ellipse&quot;,contains = &quot;Shape&quot;,slots=list(radius=&quot;numeric&quot;),prototype = list(radius=c(1,1),shape=&quot;Ellipse&quot;)) # Circle继承Ellipse setClass(&quot;Circle&quot;,contains = &quot;Ellipse&quot;,slots=list(radius=&quot;numeric&quot;),prototype=list(radius=1,shape=&quot;Circle&quot;)) # 定义area接口 setGeneric(&quot;area&quot;,function(obj,...) standardGeneric(&quot;area&quot;)) ## [1] &quot;area&quot; # 定义area的Ellipse实现 setMethod(&quot;area&quot;,&quot;Ellipse&quot;,function(obj,...){ cat(&quot;Ellipse Area: \\n&quot;) pi*prod(obj@radius) }) ## [1] &quot;area&quot; # 定义area的Circle实现 setMethod(&quot;area&quot;,&quot;Circle&quot;,function(obj,...){ cat(&quot;Circle Area:\\n&quot;) pi*obj@radius^2 }) ## [1] &quot;area&quot; # 定义circum接口 setGeneric(&quot;circum&quot;,function(obj,...) standardGeneric(&quot;circum&quot;)) ## [1] &quot;circum&quot; # 定义circum的ellipse实现 setMethod(&quot;circum&quot;,&quot;Ellipse&quot;,function(obj,...){ cat(&quot;Ellipse circum:\\n&quot;) 2*pi*sqrt((obj@radius[1]^2+obj@radius[2]^2)/2) }) ## [1] &quot;circum&quot; # 定义circum的circle实现 setMethod(&quot;circum&quot;,&quot;Circle&quot;,function(obj,...){ cat(&quot;Ellipse circum:\\n&quot;) 2*pi*obj@radius }) ## [1] &quot;circum&quot; # 创建实例 e1 &lt;- new(&quot;Ellipse&quot;,name=&quot;e1&quot;,radius=c(2,5)) e2 &lt;- new(&quot;Circle&quot;,name=&quot;e2&quot;,radius=2) #计算面积和周长 area(e1) ## Ellipse Area: ## [1] 31.41593 circum(e1) ## Ellipse circum: ## [1] 23.92566 area(e2) ## Circle Area: ## [1] 12.56637 circum(e2) ## Ellipse circum: ## [1] 12.56637 这样是不是显得更合理？ 4.6.3 任务3：增加矩形的图形处理 进一步扩充图形库需要加入矩形和正方形 定义矩形的数据结构，计算面积和周长 定义长方形的数据结构，计算面积和周长 矩形是正方形的父类，正方形是矩形的子类 # 定义矩形Rectangle，继承Shape setClass(&quot;Rectangle&quot;,contains = &quot;Shape&quot;,slots=list(edges=&quot;numeric&quot;),prototype=list(edges=c(1,1),shape=&quot;Rectangle&quot;)) # 定义正方形Square继承Rectangle setClass(&quot;Square&quot;,contains = &quot;Rectangle&quot;,slots=list(edges=&quot;numeric&quot;),prototype = list(edges=1,shape=&quot;Square&quot;)) # 定义area的Rectangle实现 setMethod(&quot;area&quot;,&quot;Rectangle&quot;,function(obj,...){ cat(&quot;Rectangle Area:\\n&quot;) prod(obj@edges) }) ## [1] &quot;area&quot; # 定义area的Square setMethod(&quot;area&quot;,&quot;Square&quot;,function(obj,...){ cat(&quot;Square Area: \\n&quot;) obj@edges^2 }) ## [1] &quot;area&quot; # 定义circum的Rectangle实现 setMethod(&quot;circum&quot;,&quot;Rectangle&quot;,function(obj,...){ cat(&quot;Rectangle Circum:\\n&quot;) 2*sum(obj@edges) }) ## [1] &quot;circum&quot; # 定义circum的Square实现 setMethod(&quot;circum&quot;,&quot;Square&quot;,function(obj,...){ cat(&quot;Square circum:\\n&quot;) 4*obj@edges }) ## [1] &quot;circum&quot; # 创建实例 r1 &lt;- new(&quot;Rectangle&quot;,name=&quot;r1&quot;,edges=c(2,5)) s1 &lt;- new(&quot;Square&quot;,name=&#39;s1&#39;,edges=2) # 计算矩形的面积和周长 area(r1) ## Rectangle Area: ## [1] 10 circum(r1) ## Rectangle Circum: ## [1] 14 area(s1) ## Square Area: ## [1] 4 circum(s1) ## Square circum: ## [1] 8 这样，图形库就支持4种图形了，用面向对象的结构去设计，就会非常清晰。 4.6.4 任务4：在基类Shape中增加shape属性和getShape方法 对图形库的所有图形定义图形类型的变量shape,然后在提供一个getShape函数来检查实例中的shape变量。 # 重新定义基类Shape，增加shape属性 setClass(&quot;Shape&quot;,slots=list(name=&quot;character&quot;,shape=&quot;character&quot;)) # 定义getShape接口 setGeneric(&quot;getShape&quot;,function(obj,...){ standardGeneric(&quot;getShape&quot;) }) ## [1] &quot;getShape&quot; # 定义getShape实现 setMethod(&quot;getShape&quot;,&quot;Shape&quot;,function(obj,...){ cat(obj@shape,&quot;\\n&quot;) }) ## [1] &quot;getShape&quot; 其实，这样改动一下就OK了，我们只需要重新实例化每个图形的对象就好了。 # 实例化一个Square对象，并给shape属性赋值 s1 &lt;- new(&quot;Square&quot;,name=&#39;s1&#39;,edges=2,shape=&#39;Square&#39;) # 调用基类的getShape()函数 getShape(s1) ## Square 如果再多做一步，可以修改每个对象的定义，增加shape属性的默认值。 setClass(&quot;Ellipse&quot;,contains = &#39;Shape&#39;,slots=list(radius=&quot;numeric&quot;),prototype = list(radius=c(1,1),shape=&quot;Ellipse&quot;)) 通过这节的例子，我们全面的了解了R语言的面向的使用和S4对象系统的面向对象的程序设计。 在程序猿的世界里，世间万物都可以抽象成对象！ "],
["RC.html", "第 5 章 基于RC的面向对象编程 5.1 RC对象系统的介绍 5.2 如何创建RC类？ 5.3 对象赋值 5.4 定义对象的方法 5.5 RC对象内置方法和内置属性 5.6 RC类的辅助函数 5.7 RC对象实例", " 第 5 章 基于RC的面向对象编程 RC(Reference Class)对象系统从底层上改变了原有S3和S4对象系统的设计，去掉了泛型函数，其真正的以类为基础实现面向对象的特征。在R中常备简记为R5http://adv-r.had.co.nz/R5.html(但这不是官方的名称)，而是为了从形式上和S3和S4相匹配。 5.1 RC对象系统的介绍 RC是Reference Classes的简称，又称为R5,在R语言的2.12版本被引入，是最新一代的面向对象系统。 RC不同于原来的S3和S4独享系统，RC队形系统得的方法是在类中自定的，而不是泛型函数。RC对象的行为更相似于其他的编程语言，实例化队形的语法也有所改变。 从面向对象的角度来说，我们下面重定义几个名词。 类：面向对象系统的基本类型，类是静态结构定义。 对象：类实例化之后，在内存中生成结构体 方法：是类中的函数定义，不通过泛型函数实现。 5.2 如何创建RC类？ RC对象是以类为基本类型，有专门的类的定义函数setRefClass(),实例化则通过类的方法生成。 5.2.1 setRefClass() setRefClass(Class,fields=,contains=,methods=,where=,...) 参数列表： Class: 定义类名 fields: 定义属性和属性类型 contains:定义父类，继承关系 methods: 定义类中的方法 where: 定义存储空间 从setRefClass()函数的定义来看，参数比S4的setClass()函数变少了 5.2.2 创建RC类和实例 # 定义一个RC类 User &lt;- setRefClass(&quot;User&quot;,fields=list(name=&quot;character&quot;)) # 查看User的定义 User ## Generator for class &quot;User&quot;: ## ## Class fields: ## ## Name: name ## Class: character ## ## Class Methods: ## &quot;field&quot;, &quot;trace&quot;, &quot;getRefClass&quot;, &quot;initFields&quot;, &quot;copy&quot;, &quot;callSuper&quot;, ## &quot;.objectPackage&quot;, &quot;export&quot;, &quot;untrace&quot;, &quot;getClass&quot;, &quot;show&quot;, ## &quot;usingMethods&quot;, &quot;.objectParent&quot;, &quot;import&quot; ## ## Reference Superclasses: ## &quot;envRefClass&quot; # 实例化一个User对象u1 u1 &lt;- User$new(name=&#39;u1&#39;) # 查看u1对对象 u1 ## Reference class object of class &quot;User&quot; ## Field &quot;name&quot;: ## [1] &quot;u1&quot; # 检查User类的类型 library(pryr) class(User) ## [1] &quot;refObjectGenerator&quot; ## attr(,&quot;package&quot;) ## [1] &quot;methods&quot; is.object(User) ## [1] TRUE otype(User) ## [1] &quot;RC&quot; # 检查u1的类型 class(u1) ## [1] &quot;User&quot; ## attr(,&quot;package&quot;) ## [1] &quot;.GlobalEnv&quot; is.object(u1) ## [1] TRUE otype(u1) ## [1] &quot;RC&quot; 5.2.3 创建一个有继承关系的RC类 # 创建RC类User User &lt;- setRefClass(&quot;User&quot;,fields=list(name=&quot;character&quot;)) # 创建User的子类Member Member &lt;- setRefClass(&quot;Member&quot;,contains=&quot;User&quot;,fields=list(manager=&quot;User&quot;)) # 实例化User manager &lt;- User$new(name=&quot;manager&quot;) # 实例化一个son对象 member &lt;- Member$new(name=&quot;member&quot;,manager=manager) # 查看Mebmber对象 member ## Reference class object of class &quot;Member&quot; ## Field &quot;name&quot;: ## [1] &quot;member&quot; ## Field &quot;manager&quot;: ## Reference class object of class &quot;User&quot; ## Field &quot;name&quot;: ## [1] &quot;manager&quot; # 查看member对象的name属性 member$name ## [1] &quot;member&quot; # 查看member对象的manager属性 member$manager ## Reference class object of class &quot;User&quot; ## Field &quot;name&quot;: ## [1] &quot;manager&quot; # 查看对象的属性类型 otype(member$name) ## [1] &quot;base&quot; otype(member$manager) ## [1] &quot;RC&quot; 5.2.4 RC对象的默认值 RC类有一个指定构造器方法$initialize(),这个构造器方法在实例化对象时，会自动被运行一次，通过这个构造方法可以设置属性的默认值。 # 定义一个RC类 User &lt;- setRefClass(&quot;User&quot;, # 定义两个属性 fields=list(name=&quot;character&quot;,level=&quot;numeric&quot;), methods = list(initialize=function(name,level){ print(&quot;User::initialize&quot;) # 给属性增加默认值 name &lt;&lt;- &quot;conan&quot; level &lt;&lt;- 1 })) # 实例化u1 u1 &lt;- User$new() ## [1] &quot;User::initialize&quot; # 查看对象u1属性被增加了默认值 u1 ## Reference class object of class &quot;User&quot; ## Field &quot;name&quot;: ## [1] &quot;conan&quot; ## Field &quot;level&quot;: ## [1] 1 5.3 对象赋值 # 定义User类 User &lt;- setRefClass(&quot;User&quot;,fields=list(name=&#39;character&#39;,age=&#39;numeric&#39;,gender=&#39;factor&#39;)) # 定义一个factor类型 genderFactor &lt;- factor(c(&#39;F&#39;,&#39;M&#39;)) # 实例化u1 u1 &lt;- User$new(name=&quot;u1&quot;,age=44,gender=genderFactor[1]) # 查看age属性值 u1$age ## [1] 44 给u1的age属性赋值 # 重新赋值 u1$age &lt;- 10 # age属性改变 u1$age ## [1] 10 把u1对象赋给u2对象 # 把u1赋值给u2对象 u2 &lt;- u1 # 查看u2的age属性 u2$age ## [1] 10 # 重新赋值 u1$age &lt;- 20 # 查看u1,u2的age属性都发生了改变 u1$age ## [1] 20 u2$age ## [1] 20 这是由于把u1赋值给u2，传递的是u1的实例化对象的引用，而不是值本身，这一点与其他语言中对象赋值时一样的。 如果想进行赋值而不是引入传递，可以进行下面的操作 # 调用u1的内置方法copy(),赋值给u3 u3 &lt;- u1$copy() # 查看u3的age属性 u3$age ## [1] 20 # 重新赋值,u3的age属性值并未变化 u1$age &lt;- 30 对引入关系把我，可以减少值传递过程中的内存复制过程，可以让我们的程序运行效率更高。 5.4 定义对象的方法 在S3,S4的对象系统中，我们实现对象行为时，都是借助于泛型函数实现的。这种实现方法的最大问题是：在定义函数和对象的代码是分离的，需要在运行时，通过判断对象的类型完成方法的调用。而RC对象系统中，方法可以定义在类的内部，通过实例化的对象完成方法的调用。 # 定义一个RC类包括方法 User &lt;- setRefClass(&quot;User&quot;,fields=list(name=&quot;character&quot;,favorite=&#39;vector&#39;), # 方法属性 methods= list( # 增加一个兴趣 addFavorite = function(x){ favorite &lt;&lt;- c(favorite,x) }, # 删除一个兴趣 delFavorite = function(x){ favorite &lt;&lt;- favorite[-which(favorite==x)] }, # 重新定义兴趣列表 setFavorite = function(x){ favorite &lt;&lt;- x } )) # 实例化对象u1 u1 &lt;- User$new(name=&quot;u1&quot;,favorite=c(&#39;movie&#39;,&#39;football&#39;)) # 查看u1对象 u1 ## Reference class object of class &quot;User&quot; ## Field &quot;name&quot;: ## [1] &quot;u1&quot; ## Field &quot;favorite&quot;: ## [1] &quot;movie&quot; &quot;football&quot; 接下来进行方法操作 # 删除一个兴趣 u1$delFavorite(&quot;football&quot;) # 查看兴趣属性 u1$favorite ## [1] &quot;movie&quot; 直接到方法定义到类的内部，通过实例化的对象进行访问。这样就做到了，在定义时就能保证了方法的作用域，减少运行时检查的系统开销。 5.5 RC对象内置方法和内置属性 对于RC的实例化对象，除了我们自己定义的方法函数，还有几个内置的方法。之前属性赋值赋值时使用的copy()方法，就是其中之一 5.5.1 内置方法： initialize类的初始化函数，用于设置属性的默认值，只有在类定义的方法中使用。 callSuper调用父类的同名方法，只能在类定义的方法中使用 copy复制实例化对象的所有属性 initFields给对象的属性赋值 field查看属性或给属性赋值 getClass查看对象的类定义 getRefClass()同getClass() show 查看当前对象 export查看属性值以类为作用域 import 把一个对象的属性值赋值给另一个对象 trace跟踪对象中方法调用，用于程序debug untrace取消跟踪 usingMethods用于实现方法调用，只能在类定义的方法中使用，这个方法不利于程序的健壮性，所以不建议使用。 接下来我们使用这些内置方法。 # 类User User &lt;- setRefClass(&quot;User&quot;, fields=list(name=&quot;character&quot;,level=&quot;numeric&quot;), methods = list( initialize=function(name,level){ print(&quot;User::initialize&quot;) name &lt;&lt;- &quot;conan&quot; level &lt;&lt;- 1 }, addLevel = function(x){ print(&quot;User::addlevel&quot;) level&lt;&lt;-level+x }, addHighLevel = function(){ print(&quot;user::addHighLevel&quot;) addLevel(2) } )) 定义子类Member继承父类User,并包括同名方法addLevel覆盖父类的方法，在addLevel方法中，会调用父类的同名方法。 # 子类Member Member &lt;- setRefClass(&quot;Member&quot;,contains=&quot;User&quot;, # 子类中的属性 fields = list(age=&#39;numeric&#39;), methods=list( # 覆盖父类的同名方法 addLevel = function(x){ print(&quot;Member::addLevel&quot;) callSuper(x) level &lt;&lt;- level+1 } ) ) 分别实例化对象u1,m1 # 实例化u1 u1 &lt;- User$new(name=&#39;u1&#39;,level=10) ## [1] &quot;User::initialize&quot; # 查看u1对象，$new()不能实现赋值操作 u1 ## Reference class object of class &quot;User&quot; ## Field &quot;name&quot;: ## [1] &quot;conan&quot; ## Field &quot;level&quot;: ## [1] 1 # 通过$initFields（）向属性赋值 u1$initFields(name=&#39;u1&#39;,level=10) ## Reference class object of class &quot;User&quot; ## Field &quot;name&quot;: ## [1] &quot;u1&quot; ## Field &quot;level&quot;: ## [1] 10 # 实例化m1 m1 &lt;- Member$new() ## [1] &quot;User::initialize&quot; m1$initFields(name=&#39;m1&#39;,level=100,age=12) ## Reference class object of class &quot;Member&quot; ## Field &quot;name&quot;: ## [1] &quot;m1&quot; ## Field &quot;level&quot;: ## [1] 100 ## Field &quot;age&quot;: ## [1] 12 执行$copy()方法，赋值对象属性并传值。 # 属性赋值到u2 u2 &lt;- u1$copy() ## [1] &quot;User::initialize&quot; 使用方法field()，查看并给level属性赋值 # 查看level属性值 u1$field(&#39;level&#39;) ## [1] 10 # 给level属性值为1 u1$field(&#39;level&#39;,1) # 查看level属性值 u1$level ## [1] 1 使用getRefClass()和getClass()方法查看u1对象的类定义。 # 类引入的定义 m1$getRefClass() ## Generator for class &quot;Member&quot;: ## ## Class fields: ## ## Name: name level age ## Class: character numeric numeric ## ## Class Methods: ## &quot;addLevel#User&quot;, &quot;import&quot;, &quot;.objectParent&quot;, &quot;usingMethods&quot;, &quot;show&quot;, ## &quot;getClass&quot;, &quot;untrace&quot;, &quot;export&quot;, &quot;.objectPackage&quot;, &quot;callSuper&quot;, ## &quot;copy&quot;, &quot;initFields&quot;, &quot;getRefClass&quot;, &quot;trace&quot;, &quot;field&quot;, &quot;initialize&quot;, ## &quot;addLevel&quot;, &quot;addHighLevel&quot; ## ## Reference Superclasses: ## &quot;User&quot;, &quot;envRefClass&quot; # 类定义 m1$getClass() ## Reference Class &quot;Member&quot;: ## ## Class fields: ## ## Name: name level age ## Class: character numeric numeric ## ## Class Methods: ## &quot;addLevel#User&quot;, &quot;import&quot;, &quot;.objectParent&quot;, &quot;usingMethods&quot;, &quot;show&quot;, ## &quot;getClass&quot;, &quot;untrace&quot;, &quot;export&quot;, &quot;.objectPackage&quot;, &quot;callSuper&quot;, ## &quot;copy&quot;, &quot;initFields&quot;, &quot;getRefClass&quot;, &quot;trace&quot;, &quot;field&quot;, &quot;initialize&quot;, ## &quot;addLevel&quot;, &quot;addHighLevel&quot; ## ## Reference Superclasses: ## &quot;User&quot;, &quot;envRefClass&quot; # 通过otype查看类型的不同 otype(m1$getRefClass()) ## [1] &quot;RC&quot; otype(m1$getClass()) ## [1] &quot;S4&quot; 使用$show()方法查看属性值，$show()，同show()函数，对象直接输出时就是调用了$show()方法 m1$show() ## Reference class object of class &quot;Member&quot; ## Field &quot;name&quot;: ## [1] &quot;m1&quot; ## Field &quot;level&quot;: ## [1] 100 ## Field &quot;age&quot;: ## [1] 12 show(m1) ## Reference class object of class &quot;Member&quot; ## Field &quot;name&quot;: ## [1] &quot;m1&quot; ## Field &quot;level&quot;: ## [1] 100 ## Field &quot;age&quot;: ## [1] 12 m1 ## Reference class object of class &quot;Member&quot; ## Field &quot;name&quot;: ## [1] &quot;m1&quot; ## Field &quot;level&quot;: ## [1] 100 ## Field &quot;age&quot;: ## [1] 12 使用$trace()跟踪方法调用,再用$untrace()方法取消跟踪绑定 # 对我addLevel()方法跟踪 m1$trace(&#39;addLevel&#39;) ## Tracing reference method &quot;addLevel&quot; for object from class ## &quot;Member&quot; ## [1] &quot;addLevel&quot; # 调用addlevel()方法,tracing m1$addLevel(1)被打印跟踪生效 m1$addLevel(1) ## Tracing m1$addLevel(1) on entry ## [1] &quot;Member::addLevel&quot; ## [1] &quot;User::addlevel&quot; # 取消对addLevel()方法跟踪 m1$untrace(&quot;addLevel&quot;) ## Untracing reference method &quot;addLevel&quot; for object from class ## &quot;Member&quot; ## [1] &quot;addLevel&quot; 使用$export()方法,以类作为作用域查看属性 # 查看在member类中的属性 m1$export(&quot;Member&quot;) ## Reference class object of class &quot;Member&quot; ## Field &quot;name&quot;: ## [1] &quot;m1&quot; ## Field &quot;level&quot;: ## [1] 102 ## Field &quot;age&quot;: ## [1] 12 # 查看在User类中的属性，当前作用域不包括age属性 m1$export(&quot;User&quot;) ## [1] &quot;User::initialize&quot; ## Reference class object of class &quot;User&quot; ## Field &quot;name&quot;: ## [1] &quot;m1&quot; ## Field &quot;level&quot;: ## [1] 102 使用$import()方法,把一个对象的属性值赋值给另一个对象 # 实例化m2 m2 &lt;- Member$new() ## [1] &quot;User::initialize&quot; m2 ## Reference class object of class &quot;Member&quot; ## Field &quot;name&quot;: ## [1] &quot;conan&quot; ## Field &quot;level&quot;: ## [1] 1 ## Field &quot;age&quot;: ## numeric(0) # 把m1对象的值赋值给m2对象 m2$import(m1) 5.5.2 内置属性 RC对象实例化后，有两个内置属性 .self 实例化对象自身 .refClassDef类的定义类型 # $.self属性 m1$.self ## Reference class object of class &quot;Member&quot; ## Field &quot;name&quot;: ## [1] &quot;m1&quot; ## Field &quot;level&quot;: ## [1] 102 ## Field &quot;age&quot;: ## [1] 12 # m1$.self和m1完全相同 identical(m1$.self,m1) ## [1] TRUE # 查看类型 otype(m1$.self) ## [1] &quot;RC&quot; # $.refClassDef属性 m1$.refClassDef ## Reference Class &quot;Member&quot;: ## ## Class fields: ## ## Name: name level age ## Class: character numeric numeric ## ## Class Methods: ## &quot;addLevel#User&quot;, &quot;import&quot;, &quot;.objectParent&quot;, &quot;usingMethods&quot;, &quot;show&quot;, ## &quot;getClass&quot;, &quot;untrace&quot;, &quot;export&quot;, &quot;.objectPackage&quot;, &quot;callSuper&quot;, ## &quot;copy&quot;, &quot;initFields&quot;, &quot;getRefClass&quot;, &quot;trace&quot;, &quot;field&quot;, &quot;initialize&quot;, ## &quot;addLevel&quot;, &quot;addHighLevel&quot; ## ## Reference Superclasses: ## &quot;User&quot;, &quot;envRefClass&quot; # 与getClass()相同 identical(m1$.refClassDef,m1$getClass()) ## [1] TRUE # 查看类型 otype(m1$.refClassDef) ## [1] &quot;S4&quot; 5.6 RC类的辅助函数 当定义好了RC类的结构，有一些辅助函数可以帮助我们查看类型的属性和方法，上面用于创建实例化的对象的$new()函数，也属于这类辅助函数 new用于实例化对象 help用于查询类中定义的所有方法 methods列出类中定义的所有方法 fields列出类中定义的所有属性 lock给属性加锁，实例化的对象的属性只允许赋值依次，即赋值变量不可修改 trace跟踪方法 accessors给属性生成get/set方法 接下来，使用辅助函数，继续定义之前的USER类的结构 # 定义User类 User &lt;- setRefClass(&quot;User&quot;, fields=list(name=&quot;character&quot;,level=&#39;numeric&#39;), methods=list( initialize=function(name,level){ print(&quot;User::initialize&quot;) name &lt;&lt;- &#39;conan&#39; level &lt;&lt;- 1 }, addLevel = function(x){ print(&quot;User::addLevel&quot;) level &lt;&lt;- level+x }, addHighLevel = function(){ print(&quot;User::addhighLevel&quot;) addLevel(2) } )) # 实例化对象u1 u1 &lt;- User$new() ## [1] &quot;User::initialize&quot; # 列出User类中的属性 User$fields() ## name level ## &quot;character&quot; &quot;numeric&quot; # 列出User类中的方法 User$methods() ## [1] &quot;.objectPackage&quot; &quot;.objectParent&quot; &quot;addHighLevel&quot; &quot;addLevel&quot; ## [5] &quot;callSuper&quot; &quot;copy&quot; &quot;export&quot; &quot;field&quot; ## [9] &quot;getClass&quot; &quot;getRefClass&quot; &quot;import&quot; &quot;initFields&quot; ## [13] &quot;initialize&quot; &quot;show&quot; &quot;trace&quot; &quot;untrace&quot; ## [17] &quot;usingMethods&quot; # 查看User类中的方法调用 User$help(&quot;addLevel&quot;) ## Call: ## $addLevel(x) User$help(&quot;show&quot;) ## Call: ## $show() 给User类中的属性,增加get/set方法 # 给level属性增加get/set方法 User$accessors(&quot;level&quot;) # 列出所有方法 User$methods() ## [1] &quot;.objectPackage&quot; &quot;.objectParent&quot; &quot;addHighLevel&quot; &quot;addLevel&quot; ## [5] &quot;callSuper&quot; &quot;copy&quot; &quot;export&quot; &quot;field&quot; ## [9] &quot;getClass&quot; &quot;getLevel&quot; &quot;getRefClass&quot; &quot;import&quot; ## [13] &quot;initFields&quot; &quot;initialize&quot; &quot;setLevel&quot; &quot;show&quot; ## [17] &quot;trace&quot; &quot;untrace&quot; &quot;usingMethods&quot; 使用$trace()函数,跟踪addLevel方法 使用$lock()函数，把level属性设置为常量 # 锁定level属性 User$lock(&quot;level&quot;) # 查看User类中被锁定的属性 User$lock() ## [1] &quot;level&quot; # 实例化u3，level就被初始化依次 u3 &lt;- User$new() ## [1] &quot;User::initialize&quot; # 给level属性再次赋值出错 #u3$level = 1 5.7 RC对象实例 我们用RC面向对象的系统做一个例子，定义一套动物叫声模型 5.7.1 任务1：定义动物的数据结构和发声方法 定义animal为动物的基类，包括：猫，狗，鸭 # 创建Animal类，包括name属性,构造方法initialize（），叫声方法bark() Animal &lt;- setRefClass(&quot;Animal&quot;, fields=list(name=&quot;character&quot;), methods=list( initialize = function(name){ name &lt;&lt;- &quot;Animal&quot; }, bark = function()print(&quot;Animal::bark&quot;) )) # 创建Cat类，继承Animal类，并重写（overwrite #)了initialize()和bark() Cat &lt;- setRefClass(&quot;Cat&quot;,contains=&quot;Animal&quot;, methods=list( initialize = function(name) name &lt;&lt;- &#39;cat&#39;, bark = function() print(paste(name,&quot;is miao miao&quot;)) )) # 创建Dog类 Dog &lt;- setRefClass(&quot;Dog&quot;,contains=&quot;Animal&quot;, methods=list( initialize = function(name) name &lt;&lt;- &#39;Dog&#39;, bark = function() print(paste(name,&quot;is wang wang&quot;)) )) # 创建Duck类 Duck&lt;- setRefClass(&quot;Duck&quot;,contains=&quot;Animal&quot;, methods=list( initialize = function(name) name &lt;&lt;- &#39;Duck&#39;, bark = function() print(paste(name,&quot;is ga ga&quot;)) )) 接下来，我们实例化对象，然后研究他们的叫声 # 创建cat实例 cat &lt;- Cat$new() cat$name ## [1] &quot;cat&quot; # cat叫声 cat$bark() ## [1] &quot;cat is miao miao&quot; 5.7.2 任务2：定义动物的体貌特征 动物的体貌特征包括头，身体，肢，翅膀,我们只增加肢，只是在Animal中添加limbs属性 5.7.3 任务3：定义动物的行动方式 Animal中定义action方法，每一个子类使用callSuper()重写该方法。 通过这个例子，我们应该可以全面的理解R语言中基于RC对象系统的面向对象的程序设计，我本人推荐大家使用RC面向对象，因为这更像是传统语言的面向对象方式。 "],
["R6.html", "第 6 章 基于R6的面向对象", " 第 6 章 基于R6的面向对象 "],
["env.html", "第 7 章 环境 7.1 环境基础 7.2 环境递归 7.3 函数环境 7.4 绑定名字和数值 7.5 显式环境 7.6 总结", " 第 7 章 环境 环境就是作用域发挥作用的数据结构，本章将深入学习环境的概念，由于环境具有引用语义，所以本身他们也是一种很有用的数据结构，当在一个环境中对其绑定的元素进行修改时，环境不会被复制，修改会在原地进行。虽然不会经常使用引用语义，但他还是非常有用的。 7.1 环境基础 环境的作用就是将一些名字与一些值进行关联，或者绑定(bind),可以把环境看做一个装满名字的口袋 每个名字都指向存储在内存中的一个对象 e &lt;- new.env() e$a &lt;- FALSE e$b &lt;- &quot;a&quot; e$c &lt;- 2.3 e$d &lt;- 1:3 对象并不生存在环境中，所以多个名字可指向同一个对象 e$a &lt;- e$d 令人困惑的是，他们还可以指向具有相同值得不同对象 e$a &lt;- 1:3 如果对象没有指向它的名字，那么这个对象就会被垃圾回收器自动删除。 每个环境都有父环境，他是另外一个环境。在下图中，黑色小圆球代表指向父环境的指针，父环境用于实现词法作用域:如果一个名字在一个环境中没有找到，R就会到他的父环境去找（直到找到或遍历所有环境），只有空（empty）环境没有父环境 我们可以将环境之间的关系比作家庭中成员的关系。一个环境的爷爷就是他父亲的父亲，它的祖先就包括直到空环境的所有父环境。我们基本上不会说一个环境的子环境，因为他们之间没有反向链接，给定一个环境我们没有办法找到它的子环境。 通常环境与列表相似，除一下4点外： 环境中的每个对象都有唯一的名字 环境中的对象没有顺序 环境有父环境 环境具有引用语义 更专业一点，环境是有两部分构成：对象框，它包含名称-对象的绑定关系（行为商更像一个命名列表);它的父环境。 还有4个特殊的环境： globaenv()或者全局环境，他是一个交互式的工作环境，通常情况下我们就是在这个环境工作。全局环境的父环境就是libtary()或require()添加的最后一个包 baseenv(),基础环境，他是R基础软件包的环境，他的父环境是空环境 emptyenv(),空环境，他是所有环境的祖先，也是唯一一个没有父环境的环境 environment(),他是当前环境 下面看一些环境方面的方法： search() 列出全局环境的所有父环境 search() ## [1] &quot;.GlobalEnv&quot; &quot;package:pryr&quot; &quot;package:stats&quot; ## [4] &quot;package:graphics&quot; &quot;package:grDevices&quot; &quot;package:utils&quot; ## [7] &quot;package:datasets&quot; &quot;package:methods&quot; &quot;Autoloads&quot; ## [10] &quot;package:base&quot; as.environment() 访问搜索列表中的任何环境 as.environment(&quot;package:stats&quot;) ## &lt;environment: package:stats&gt; ## attr(,&quot;name&quot;) ## [1] &quot;package:stats&quot; ## attr(,&quot;path&quot;) ## [1] &quot;D:/R-3.4.3/library/stats&quot; new.env() 手动创建一个环境，ls()可以列出将此环境的对象框中的所有绑定关系列出来，可以使用parent.env()查看他的父环境。 e &lt;- new.env() parent.env(e) ## &lt;environment: R_GlobalEnv&gt; ls(e) ## character(0) 对一个环境中的绑定关系进行修改的最简单的方法就是将其看做列表 e$a &lt;- 1 e$b &lt;- 2 ls(e) ## [1] &quot;a&quot; &quot;b&quot; e$a ## [1] 1 默认情况下，ls()只能列出不是一“.”开始的名字，可以通过设置参数all.names=TRUE来显示一个环境中的所有绑定关系： e$.a &lt;- 2 ls(e) ## [1] &quot;a&quot; &quot;b&quot; ls(e,all.names=TRUE) ## [1] &quot;.a&quot; &quot;a&quot; &quot;b&quot; ls.str() 它可以将环境中的所有对象都显示出来，比str()更有用 str(e) ## &lt;environment: 0x000000001907e4e0&gt; ls.str(e) ## a : num 1 ## b : num 2 获取绑定值 e$c &lt;- 3 e$c ## [1] 3 e[[&quot;c&quot;]] ## [1] 3 get(&quot;c&quot;,envir=e) ## [1] 3 从环境中删除对象 e &lt;- new.env() e$a &lt;- 1 e$a &lt;- NULL #这样相当于创建了一个新的对象 ls(e) ## [1] &quot;a&quot; rm(&quot;a&quot;,envir=e) ls(e) ## character(0) exists() 确定一个绑定是否存在 x &lt;- 10 exists(&quot;x&quot;,envir=e) #查找父环境 ## [1] TRUE exists(&quot;x&quot;,envir=e,inherits=FALSE) #不希望在父环境中查找 ## [1] FALSE identical() identical()与==是不同的，是对两个环境进行比较 identical(globalenv(),environment()) ## [1] TRUE #globalenv()==environment() 7.2 环境递归 环境可以构成一棵树，因此我们非常方便的写出一个递归函数，pryr::where()会使用R的作用域法则找到定义这个名字的空间 library(pryr) x &lt;- 5 # where函数由两个参数，一个是查找的名字(字符串)，一个是开始查找的环境 where(&quot;x&quot;) ## &lt;environment: R_GlobalEnv&gt; where &lt;- function(name,env=parent.frame()){ if(identical(env,emptyenv())){ # Base case stop(&quot;Can&#39;t find&quot;,name,call.=FALSE) }else if(exists(name,envir=env,inherits=FALSE)){ #Success case env }else{ #Recursive case where(name,parent.env(env)) } } 有三种情况： 基本情况： 已经到达空环境，但没有找到绑定，抛出一个错误 成功情况： 在这个环境中存在该对象，返回该环境 递归情况：在这个环境中没有找到该环境的对象，所以尝试在父环境中继续查找 7.3 函数环境 大对数环境并不是通过new.env()函数创建的，而是使用函数的结果，本节将讨论4种和函数相关的环境：封闭，绑定，执行和调用。 封闭环境： 创建函数的环境，每个函数有且仅有一个封闭环境 使用&lt;-讲一个函数和一个名字进行绑定，就可以定义一个绑定环境 调用函数创建一个临时的执行环境，用来存储执行期间创建的各种变量 每个执行环境都与一个调用环境关联，他说明函数在哪调用 7.3.1 封闭环境 当创建一个函数，他就获得对创建他的函数的引用，这就是封闭环境，他用作此法作用域。为了确定一个函数的封闭空间，只需调用environment()并将函数名作为第一个参数 y &lt;- 1 f &lt;- function(x) x+y environment(f) ## &lt;environment: R_GlobalEnv&gt; 下图中，圆角矩形代表函数，黑色菱形代表一个函数的封闭环境 7.3.2 绑定环境 上图太简单，因为函数没有名字，函数的名字可以通过绑定来定义，一个函数的绑定环境就是与其绑定的所有环境，下图更好的反映这种关系，因为封闭环境包含一个从f到环境的绑定 这种情况封闭环境和绑定环境是相同的，当将一个函数分配给另一个不同的环境，那么他们就同了 e &lt;- new.env() e$g &lt;- function() 1 封闭函数属于该环境，永远也不会发生改变，甚至将该函数移动到其他环境中，封闭环境决定了这个函数该如何找到值，而绑定环境空间决定如何找到该函数。 绑定空间与封闭空间的区别在于软件包命名空间是非常重要的，例如如果软件包中A使用基础包中的mean()函数，那么如果软件包B也创建了自己的mean()函数会有什么后果呢？命名空间确保软件包A使用基础包中的mean(),而不受软件包B的影响（除非显式的调用） 命名空间使用环境来实现，利用函数不一定存在于他们的封闭环境中的事实，例如基础包中的sd()函数，它的封闭环境与绑定环境是不同的 environment(sd) ## &lt;environment: namespace:stats&gt; where(&quot;sd&quot;) ## &lt;environment: package:stats&gt; ## attr(,&quot;name&quot;) ## [1] &quot;package:stats&quot; ## attr(,&quot;path&quot;) ## [1] &quot;D:/R-3.4.3/library/stats&quot; 函数sd()的定义使用var()，但是如果创建自己的var()函数，那么他也不会影响sd() x &lt;- 1:10 sd(x) ## [1] 3.02765 var &lt;- function(x,na.rm=TRUE) 100 sd(x) ## [1] 3.02765 这是可执行的，因为每个软件包有两个与他相关的环境：软件包环境和命名空间环境。软件包环境包含所有可以访问的公共函数，并且存放在搜索路径上，命名空间环境包含所有函数，并且它的父环境也是比较重要的环境，其中包含了这个软件包需要的所有函数的绑定。软件包中的每一个到处函数都绑定到软件包环境，但都在命名空间环境中，如下图展示杉树关系： 当输入var时，R首先会到全局环境中进行查找，当sd()查找var()时，他首先到命名空间中查找，而永远不会到globalenv()中查找。 7.3.3 执行环境 第一次执行下面的函数他返回什么？，第二次呢？ g &lt;- function(x) { if(!exists(&quot;a&quot;,inherits=FALSE)){ message(&quot;Default a&quot;) a &lt;- 1 } else { a &lt;- a + 1 } a } g(10) ## Default a ## [1] 1 g(10) ## Default a ## [1] 1 每次调用这个函数都返回相同的值，每次调用函数时都创建一个新的宿主执行环境，执行环境的父环境就是函数的封闭环境，一旦函数执行结束，这个环境就会被销毁。 通过图形简单了解这个过程：虚线包围的就是执行环境 h &lt;- function(x) { a &lt;- 2 x + a } y &lt;- h(1) 1.用 \\(x=1\\) 调用函数 2.a被赋值为2 3.函数完成后返回值为3 当在另一个函数中创建一个函数的时候，子函数的封闭函数就是父函数的执行环境，而且执行环境也不再是临时的了。下面的栗子用一个函数工厂(相当于python闭包，装饰器)plus()来说明这个想法。我们使用这个工厂创建一个plus_one()函数，plus_one()的封闭环境是plus()的执行环境，其中x与数值1绑定 plus &lt;- function(x){ function(y) x+y message(&quot;Note: &quot;,&quot;plus_one also a function&quot;) } plus_one &lt;- plus(1) ## Note: plus_one also a function #注意plus_one也是一个函数 7.3.4 调用环境 查看下面代码。当代码运行时，你期望i()返回什么？ h &lt;- function(){ x &lt;- 10 function(){ def &lt;- get(&quot;x&quot;,environment()) #返回函数被调用的环境 call &lt;- get(&quot;x&quot;,parent.frame()) list(defined=def,called=call,x=x) #x } } i &lt;- h() x &lt;- 20 i() ## $defined ## [1] 10 ## ## $called ## [1] 20 ## ## $x ## [1] 10 #[1] 10 最外层的x（绑定到20）是为了分散你的注意力：使用普通作用域法则，h()首先找到自己是在哪里定义的，然后再寻找与x相关联的值10，但是在调用i()的环境中与x相关的值是多少？在定义h()的环境中x为10，在调用h()的环境中x为20. 注意每个执行环境都有两个父环境：一个调用环境和一个封闭环境。R普通作用域法则只使用封闭的父环境，parent.frame()允许你访问调用父环境。在调用环境而不是封闭环境中查找变量称为动态作用域(注：很少的编程语言使用动态作用域，这是因为动态调用使我们更难理解函数式如何运行的，动态调用主要用于开发交互式数据分析的函数) 7.4 绑定名字和数值 赋值操作其实就是就是将一个名字和一个值进行绑定，它对应于作用域，这个规则决定如何找到与一个名字相关联的值。可能你已经使用过上千次的R赋值语句，赋值操作为当前环境中的名称和对象建立一种绑定关系。名字通常包括字母，数字，.和_,但是不能以_开头，如果不遵守这些规则，则会出错。 _abc &lt;- 1 #Error: unexpected input in &quot;_&quot; 使用?Reserved可以获取完整的保留字列表，这些通常的规则也可以被重写。在一个由任何字符构成的名称的两遍加上反引号，就可以应用该名称了。 `a=b` &lt;- 3 `:)` &lt;- &quot;smile&quot; ls() ## [1] &quot;:)&quot; &quot;a&quot; &quot;a=b&quot; ## [4] &quot;Animal&quot; &quot;area&quot; &quot;b&quot; ## [7] &quot;c1&quot; &quot;c2&quot; &quot;cat&quot; ## [10] &quot;Cat&quot; &quot;circum&quot; &quot;Dog&quot; ## [13] &quot;Duck&quot; &quot;e&quot; &quot;e1&quot; ## [16] &quot;e2&quot; &quot;f&quot; &quot;f1&quot; ## [19] &quot;f1.character&quot; &quot;f1.numeric&quot; &quot;father&quot; ## [22] &quot;g&quot; &quot;genderFactor&quot; &quot;getShape&quot; ## [25] &quot;h&quot; &quot;i&quot; &quot;m1&quot; ## [28] &quot;m2&quot; &quot;manager&quot; &quot;member&quot; ## [31] &quot;Member&quot; &quot;mother&quot; &quot;n1&quot; ## [34] &quot;n2&quot; &quot;plus&quot; &quot;plus_one&quot; ## [37] &quot;r1&quot; &quot;s1&quot; &quot;son&quot; ## [40] &quot;student&quot; &quot;student.attend&quot; &quot;student.default&quot; ## [43] &quot;student.exam&quot; &quot;student.homework&quot; &quot;teacher&quot; ## [46] &quot;teacher.assignment&quot; &quot;teacher.correcting&quot; &quot;teacher.default&quot; ## [49] &quot;teacher.lecture&quot; &quot;u1&quot; &quot;u2&quot; ## [52] &quot;u3&quot; &quot;User&quot; &quot;var&quot; ## [55] &quot;work&quot; &quot;x&quot; &quot;y&quot; 除了使用反引号外，还可以使用单引号或双引号来创建非语法的绑定，但是不推荐这样做(在赋值箭头左边使用字符串属于历史问题，在R开始支持反引号之前就已经开始使用了) 普通的赋值箭头&lt;-总是在当前环境中创建一个变量。强制赋值箭头&lt;&lt;-不会再当前环境中创建变量，但是他修改父环境中已有的变量，也可以使用assign来进行深度绑定：name &lt;&lt;- value就等价于assign(“name”,value,inherits=TRUE) x &lt;- 0 f &lt;- function(){ x &lt;&lt;- 1 } f() x ## [1] 1 还有另外两个绑定：延时绑定和主动绑定 延时绑定：不是立即把结果赋给一个表达式，它创建和存储一个约定，在需要时对约定中的表达式进行求值，用特殊的赋值运算符号%&lt;d-%来创建延迟绑定,他是对delayedAssign()函数的封装，如果需要更多的控制可以使用该函数。 library(pryr) system.time(b %&lt;d-% {Sys.sleep(1); 1}) ## user system elapsed ## 0 0 0 system.time(b) ## user system elapsed ## 0 0 1 主动绑定：不是绑定到常量对象，相反，每次对其进行访问时都要重新计算。%&lt;a-%是对基础函数makeActiveBinding()的封装。 x %&lt;a-% runif(1) x ## [1] 0.650773 x ## [1] 0.5166843 rm(x) 7.5 显式环境 除了服务于作用域之外，环境也是一种很有用的数据结构，因此他们有引用语义，与R中的大多数对象不同，当你对环境进行修改时，R不会对其进行复制，例如： modify &lt;- function(x){ x$a &lt;- 2 invisible() } 如果将这个函数应用于列表，原始列表不会被改变，因为修改列表实际上是创建和修改副本 x_1 &lt;- list() x_1$a &lt;- 1 modify(x_1) x_1$a ## [1] 1 #[1] 1 但是如果将这个函数应用于环境，那么原始环境就会被修改 x_e &lt;- new.env() x_e$a &lt;- 1 modify(x_e) x_e$a ## [1] 2 #[1] 2 就像可以使用列表传递数据一样，也可以使用环境，当你创建自己的环境时，应该将父环境设置为空环境，这样确保不会从其他地方继承对象： x &lt;- 1 e1 &lt;- new.env() get(&quot;x&quot;,envir=e1) ## [1] 1 # e2 &lt;- new.env(parent=emptyenv()) # get(&quot;x&quot;,envir = e2) #Error in get(&quot;x&quot;, envir = e2) : object &#39;x&#39; not found 环境时解决下面3类常见问题的有效数据结构 避免大数据的复制 管理一个软件包的内部状态 根据名字高效的查找与其绑定的值 7.5.1 避免复制 由于环境具有引用语义，所有绝不会无意识的创建一个副本。Biocinductor包中经常使用这种技术，因为它经常需要对非常大的基因对象进行管理。在R3.1.0版本后，这种技术已经不像以前那么重要了，因为修改列表不再是深度复制了。以前修改列表的一个元素也要复制整个列表，如果有些元素非常大，就会造成昂贵的操作。 7.5.2 软件包状态 显式环境在软件包中很有用，因为他们允许你在函数调用之间保持软件包的状态，正常情况下软件包的对象是被锁定的，所以你不能直接修改他们，但是可以这样做： my_env &lt;- new.env(parent = emptyenv()) my_env$a &lt;- 1 get_a &lt;- function(){ my_env$a } set_a &lt;- function(value){ old &lt;- my_env$a my_env$a &lt;- value invisible(old) #不返回old } 7.5.3 模拟hashmap hashmap是一种非常有用的数据结构，它根据名字查找对象的时间复杂度为O(1)。环境默认提供这种行为，所以可以用它来模拟hashmap。CRAN的hash包就是用这种思想开发的 7.6 总结 截止到这，我们的R语言面型对象的内容介绍完了，回顾起来，首先我们介绍了R语言编程的一些规范，告诉读者要参考一些标准的规范构建自己的编程规范并在团队中做出调整，增加自己代码的可读性和运行效率，紧接着我们分了5章系统全面的介绍了R语言的面向对象编程:S3,S4,R5,R6;最后本章我们介绍了R语言环境的相关知识，环境不仅是作用域的描述，更是一种非常好用的数据结构。 最后希望阅读本电子书的R语言用户,阅读完本书后对你有一点点的帮助。 "],
["Reference.html", "第 8 章 参考文献", " 第 8 章 参考文献 [1].高级R语言编程指南[M]. hadley Wickham 著，李洪成等 译. [2].R语言面向对象编程 [3].数据科学中的R语言[M]. 李舰，肖凯 著. "]
]
