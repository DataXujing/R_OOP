<!DOCTYPE html>
<html >

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>R语言面向对象编程</title>
  <meta name="description" content="R语言面向对象编程">
  <meta name="generator" content="bookdown 0.7 and GitBook 2.6.7">

  <meta property="og:title" content="R语言面向对象编程" />
  <meta property="og:type" content="book" />
  
  
  <meta property="og:description" content="R语言面向对象编程" />
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="R语言面向对象编程" />
  
  <meta name="twitter:description" content="R语言面向对象编程" />
  

<meta name="author" content="徐静">


<meta name="date" content="2018-08-06">

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  
  
<link rel="prev" href="R6.html">
<link rel="next" href="Reference.html">
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />









<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>

<link rel="stylesheet" href="css\style.css" type="text/css" />
<link rel="stylesheet" href="css\toc.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="https://github.com/DataXujing/R_oop" target='blank'>项目地址</a></li>

<li class="divider"></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>写在书前</a></li>
<li class="chapter" data-level="" data-path="e5a3b0e6988e.html"><a href="e5a3b0e6988e.html"><i class="fa fa-check"></i>声明</a></li>
<li class="chapter" data-level="1" data-path="ch1.html"><a href="ch1.html"><i class="fa fa-check"></i><b>1</b> R语言编程风格指南</a><ul>
<li class="chapter" data-level="1.1" data-path="ch1.html"><a href="ch1.html#section-1.1"><i class="fa fa-check"></i><b>1.1</b> 符号和名字</a><ul>
<li class="chapter" data-level="1.1.1" data-path="ch1.html"><a href="ch1.html#section-1.1.1"><i class="fa fa-check"></i><b>1.1.1</b> 文件名</a></li>
<li class="chapter" data-level="1.1.2" data-path="ch1.html"><a href="ch1.html#section-1.1.2"><i class="fa fa-check"></i><b>1.1.2</b> 对象名</a></li>
</ul></li>
<li class="chapter" data-level="1.2" data-path="ch1.html"><a href="ch1.html#section-1.2"><i class="fa fa-check"></i><b>1.2</b> 语法</a><ul>
<li class="chapter" data-level="1.2.1" data-path="ch1.html"><a href="ch1.html#section-1.2.1"><i class="fa fa-check"></i><b>1.2.1</b> 空格</a></li>
<li class="chapter" data-level="1.2.2" data-path="ch1.html"><a href="ch1.html#section-1.2.2"><i class="fa fa-check"></i><b>1.2.2</b> 大括号</a></li>
<li class="chapter" data-level="1.2.3" data-path="ch1.html"><a href="ch1.html#section-1.2.3"><i class="fa fa-check"></i><b>1.2.3</b> 行的长度</a></li>
<li class="chapter" data-level="1.2.4" data-path="ch1.html"><a href="ch1.html#section-1.2.4"><i class="fa fa-check"></i><b>1.2.4</b> 缩进</a></li>
<li class="chapter" data-level="1.2.5" data-path="ch1.html"><a href="ch1.html#section-1.2.5"><i class="fa fa-check"></i><b>1.2.5</b> 赋值</a></li>
</ul></li>
<li class="chapter" data-level="1.3" data-path="ch1.html"><a href="ch1.html#section-1.3"><i class="fa fa-check"></i><b>1.3</b> 结构</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="ch2.html"><a href="ch2.html"><i class="fa fa-check"></i><b>2</b> R语言面向对象编程指南</a><ul>
<li class="chapter" data-level="2.1" data-path="ch2.html"><a href="ch2.html#section-2.1"><i class="fa fa-check"></i><b>2.1</b> 什么是面向对象</a></li>
<li class="chapter" data-level="2.2" data-path="ch2.html"><a href="ch2.html#r"><i class="fa fa-check"></i><b>2.2</b> R为什么要进行面向对象的编程</a></li>
<li class="chapter" data-level="2.3" data-path="ch2.html"><a href="ch2.html#r"><i class="fa fa-check"></i><b>2.3</b> R的面向对象编程</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="S3.html"><a href="S3.html"><i class="fa fa-check"></i><b>3</b> 基于S3的面向对象编程</a><ul>
<li class="chapter" data-level="3.1" data-path="S3.html"><a href="S3.html#s3"><i class="fa fa-check"></i><b>3.1</b> S3对象的介绍</a></li>
<li class="chapter" data-level="3.2" data-path="S3.html"><a href="S3.html#s3"><i class="fa fa-check"></i><b>3.2</b> 创建S3对象</a></li>
<li class="chapter" data-level="3.3" data-path="S3.html"><a href="S3.html#section-3.3"><i class="fa fa-check"></i><b>3.3</b> 泛型函数和方法调用</a></li>
<li class="chapter" data-level="3.4" data-path="S3.html"><a href="S3.html#s3"><i class="fa fa-check"></i><b>3.4</b> 查看S3对象的函数</a></li>
<li class="chapter" data-level="3.5" data-path="S3.html"><a href="S3.html#s3"><i class="fa fa-check"></i><b>3.5</b> S3对象的继承关系</a></li>
<li class="chapter" data-level="3.6" data-path="S3.html"><a href="S3.html#s3"><i class="fa fa-check"></i><b>3.6</b> S3对象的缺点</a></li>
<li class="chapter" data-level="3.7" data-path="S3.html"><a href="S3.html#s3"><i class="fa fa-check"></i><b>3.7</b> S3对象的使用</a></li>
</ul></li>
<li class="chapter" data-level="4" data-path="S4.html"><a href="S4.html"><i class="fa fa-check"></i><b>4</b> 基于S4的面向对象编程</a><ul>
<li class="chapter" data-level="4.1" data-path="S4.html"><a href="S4.html#s4"><i class="fa fa-check"></i><b>4.1</b> S4对象介绍</a></li>
<li class="chapter" data-level="4.2" data-path="S4.html"><a href="S4.html#s4"><i class="fa fa-check"></i><b>4.2</b> 创建S4对象</a><ul>
<li class="chapter" data-level="4.2.1" data-path="S4.html"><a href="S4.html#s4"><i class="fa fa-check"></i><b>4.2.1</b> 如何创建S4对象?</a></li>
<li class="chapter" data-level="4.2.2" data-path="S4.html"><a href="S4.html#s4"><i class="fa fa-check"></i><b>4.2.2</b> 创建一个S4对象实例</a></li>
<li class="chapter" data-level="4.2.3" data-path="S4.html"><a href="S4.html#s4"><i class="fa fa-check"></i><b>4.2.3</b> 创建一个有继承关系的S4对象</a></li>
<li class="chapter" data-level="4.2.4" data-path="S4.html"><a href="S4.html#s4"><i class="fa fa-check"></i><b>4.2.4</b> S4对象的默认值</a></li>
<li class="chapter" data-level="4.2.5" data-path="S4.html"><a href="S4.html#s4"><i class="fa fa-check"></i><b>4.2.5</b> S4对象的类型检查</a></li>
<li class="chapter" data-level="4.2.6" data-path="S4.html"><a href="S4.html#section-4.2.6"><i class="fa fa-check"></i><b>4.2.6</b> 从一个已经实例化的对象中创建新对象</a></li>
</ul></li>
<li class="chapter" data-level="4.3" data-path="S4.html"><a href="S4.html#section-4.3"><i class="fa fa-check"></i><b>4.3</b> 访问对象的属性</a></li>
<li class="chapter" data-level="4.4" data-path="S4.html"><a href="S4.html#s4"><i class="fa fa-check"></i><b>4.4</b> S4的泛型函数</a></li>
<li class="chapter" data-level="4.5" data-path="S4.html"><a href="S4.html#s4"><i class="fa fa-check"></i><b>4.5</b> 查看S4对象的函数</a></li>
<li class="chapter" data-level="4.6" data-path="S4.html"><a href="S4.html#s4"><i class="fa fa-check"></i><b>4.6</b> S4对象的使用</a><ul>
<li class="chapter" data-level="4.6.1" data-path="S4.html"><a href="S4.html#1"><i class="fa fa-check"></i><b>4.6.1</b> 任务1：定义一个图形库的数据结构和计算函数</a></li>
<li class="chapter" data-level="4.6.2" data-path="S4.html"><a href="S4.html#2"><i class="fa fa-check"></i><b>4.6.2</b> 任务2：重构圆形和椭圆形的设计</a></li>
<li class="chapter" data-level="4.6.3" data-path="S4.html"><a href="S4.html#3"><i class="fa fa-check"></i><b>4.6.3</b> 任务3：增加矩形的图形处理</a></li>
<li class="chapter" data-level="4.6.4" data-path="S4.html"><a href="S4.html#4shapeshapegetshape"><i class="fa fa-check"></i><b>4.6.4</b> 任务4：在基类Shape中增加shape属性和getShape方法</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="5" data-path="RC.html"><a href="RC.html"><i class="fa fa-check"></i><b>5</b> 基于RC的面向对象编程</a><ul>
<li class="chapter" data-level="5.1" data-path="RC.html"><a href="RC.html#rc"><i class="fa fa-check"></i><b>5.1</b> RC对象系统的介绍</a></li>
<li class="chapter" data-level="5.2" data-path="RC.html"><a href="RC.html#rc"><i class="fa fa-check"></i><b>5.2</b> 如何创建RC类？</a><ul>
<li class="chapter" data-level="5.2.1" data-path="RC.html"><a href="RC.html#setrefclass"><i class="fa fa-check"></i><b>5.2.1</b> setRefClass()</a></li>
<li class="chapter" data-level="5.2.2" data-path="RC.html"><a href="RC.html#rc"><i class="fa fa-check"></i><b>5.2.2</b> 创建RC类和实例</a></li>
<li class="chapter" data-level="5.2.3" data-path="RC.html"><a href="RC.html#rc"><i class="fa fa-check"></i><b>5.2.3</b> 创建一个有继承关系的RC类</a></li>
<li class="chapter" data-level="5.2.4" data-path="RC.html"><a href="RC.html#rc"><i class="fa fa-check"></i><b>5.2.4</b> RC对象的默认值</a></li>
</ul></li>
<li class="chapter" data-level="5.3" data-path="RC.html"><a href="RC.html#section-5.3"><i class="fa fa-check"></i><b>5.3</b> 对象赋值</a></li>
<li class="chapter" data-level="5.4" data-path="RC.html"><a href="RC.html#section-5.4"><i class="fa fa-check"></i><b>5.4</b> 定义对象的方法</a></li>
<li class="chapter" data-level="5.5" data-path="RC.html"><a href="RC.html#rc"><i class="fa fa-check"></i><b>5.5</b> RC对象内置方法和内置属性</a><ul>
<li class="chapter" data-level="5.5.1" data-path="RC.html"><a href="RC.html#section-5.5.1"><i class="fa fa-check"></i><b>5.5.1</b> 内置方法：</a></li>
<li class="chapter" data-level="5.5.2" data-path="RC.html"><a href="RC.html#section-5.5.2"><i class="fa fa-check"></i><b>5.5.2</b> 内置属性</a></li>
</ul></li>
<li class="chapter" data-level="5.6" data-path="RC.html"><a href="RC.html#rc"><i class="fa fa-check"></i><b>5.6</b> RC类的辅助函数</a></li>
<li class="chapter" data-level="5.7" data-path="RC.html"><a href="RC.html#rc"><i class="fa fa-check"></i><b>5.7</b> RC对象实例</a><ul>
<li class="chapter" data-level="5.7.1" data-path="S4.html"><a href="S4.html#1"><i class="fa fa-check"></i><b>5.7.1</b> 任务1：定义动物的数据结构和发声方法</a></li>
<li class="chapter" data-level="5.7.2" data-path="S4.html"><a href="S4.html#2"><i class="fa fa-check"></i><b>5.7.2</b> 任务2：定义动物的体貌特征</a></li>
<li class="chapter" data-level="5.7.3" data-path="S4.html"><a href="S4.html#3"><i class="fa fa-check"></i><b>5.7.3</b> 任务3：定义动物的行动方式</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="6" data-path="R6.html"><a href="R6.html"><i class="fa fa-check"></i><b>6</b> 基于R6的面向对象</a><ul>
<li class="chapter" data-level="6.1" data-path="R6.html"><a href="R6.html#r6"><i class="fa fa-check"></i><b>6.1</b> 初识R6</a></li>
<li class="chapter" data-level="6.2" data-path="R6.html"><a href="R6.html#r6"><i class="fa fa-check"></i><b>6.2</b> 创建R6类和实例化对象</a><ul>
<li class="chapter" data-level="6.2.1" data-path="R6.html"><a href="R6.html#r6"><i class="fa fa-check"></i><b>6.2.1</b> 如何创建R6类?</a></li>
<li class="chapter" data-level="6.2.2" data-path="R6.html"><a href="R6.html#r6"><i class="fa fa-check"></i><b>6.2.2</b> 创建R6的类和实例化对象</a></li>
<li class="chapter" data-level="6.2.3" data-path="R6.html"><a href="R6.html#section-6.2.3"><i class="fa fa-check"></i><b>6.2.3</b> 公有成员和私有成员</a></li>
</ul></li>
<li class="chapter" data-level="6.3" data-path="R6.html"><a href="R6.html#r6"><i class="fa fa-check"></i><b>6.3</b> R6类的主动绑定</a></li>
<li class="chapter" data-level="6.4" data-path="R6.html"><a href="R6.html#r6"><i class="fa fa-check"></i><b>6.4</b> R6类的继承关系</a></li>
<li class="chapter" data-level="6.5" data-path="R6.html"><a href="R6.html#r6"><i class="fa fa-check"></i><b>6.5</b> R6类的对象的静态属性</a></li>
<li class="chapter" data-level="6.6" data-path="R6.html"><a href="R6.html#r6"><i class="fa fa-check"></i><b>6.6</b> R6类的可移植类型</a></li>
<li class="chapter" data-level="6.7" data-path="R6.html"><a href="R6.html#r6"><i class="fa fa-check"></i><b>6.7</b> R6类的动态绑定</a></li>
<li class="chapter" data-level="6.8" data-path="R6.html"><a href="R6.html#r6"><i class="fa fa-check"></i><b>6.8</b> R6类的打印函数</a></li>
<li class="chapter" data-level="6.9" data-path="R6.html"><a href="R6.html#section-6.9"><i class="fa fa-check"></i><b>6.9</b> 实例化对象的存储</a></li>
<li class="chapter" data-level="6.10" data-path="R6.html"><a href="R6.html#r6"><i class="fa fa-check"></i><b>6.10</b> R6面向对象案例</a></li>
</ul></li>
<li class="chapter" data-level="7" data-path="env.html"><a href="env.html"><i class="fa fa-check"></i><b>7</b> 环境</a><ul>
<li class="chapter" data-level="7.1" data-path="env.html"><a href="env.html#section-7.1"><i class="fa fa-check"></i><b>7.1</b> 环境基础</a></li>
<li class="chapter" data-level="7.2" data-path="env.html"><a href="env.html#section-7.2"><i class="fa fa-check"></i><b>7.2</b> 环境递归</a></li>
<li class="chapter" data-level="7.3" data-path="env.html"><a href="env.html#section-7.3"><i class="fa fa-check"></i><b>7.3</b> 函数环境</a><ul>
<li class="chapter" data-level="7.3.1" data-path="env.html"><a href="env.html#section-7.3.1"><i class="fa fa-check"></i><b>7.3.1</b> 封闭环境</a></li>
<li class="chapter" data-level="7.3.2" data-path="env.html"><a href="env.html#section-7.3.2"><i class="fa fa-check"></i><b>7.3.2</b> 绑定环境</a></li>
<li class="chapter" data-level="7.3.3" data-path="env.html"><a href="env.html#section-7.3.3"><i class="fa fa-check"></i><b>7.3.3</b> 执行环境</a></li>
<li class="chapter" data-level="7.3.4" data-path="env.html"><a href="env.html#section-7.3.4"><i class="fa fa-check"></i><b>7.3.4</b> 调用环境</a></li>
</ul></li>
<li class="chapter" data-level="7.4" data-path="env.html"><a href="env.html#section-7.4"><i class="fa fa-check"></i><b>7.4</b> 绑定名字和数值</a></li>
<li class="chapter" data-level="7.5" data-path="env.html"><a href="env.html#section-7.5"><i class="fa fa-check"></i><b>7.5</b> 显式环境</a><ul>
<li class="chapter" data-level="7.5.1" data-path="env.html"><a href="env.html#section-7.5.1"><i class="fa fa-check"></i><b>7.5.1</b> 避免复制</a></li>
<li class="chapter" data-level="7.5.2" data-path="env.html"><a href="env.html#section-7.5.2"><i class="fa fa-check"></i><b>7.5.2</b> 软件包状态</a></li>
<li class="chapter" data-level="7.5.3" data-path="env.html"><a href="env.html#hashmap"><i class="fa fa-check"></i><b>7.5.3</b> 模拟hashmap</a></li>
</ul></li>
<li class="chapter" data-level="7.6" data-path="env.html"><a href="env.html#section-7.6"><i class="fa fa-check"></i><b>7.6</b> 总结</a></li>
</ul></li>
<li class="chapter" data-level="8" data-path="Reference.html"><a href="Reference.html"><i class="fa fa-check"></i><b>8</b> 参考文献</a></li>
<li class="divider"></li>
<li><a href="https://dataxujing.github.io/" target="blank">个人主页</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">R语言面向对象编程</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="env" class="section level1">
<h1><span class="header-section-number">第 7 章</span> 环境</h1>
<p>环境就是作用域发挥作用的数据结构，本章将深入学习环境的概念，由于环境具有引用语义，所以本身他们也是一种很有用的数据结构，当在一个环境中对其绑定的元素进行修改时，环境不会被复制，修改会在原地进行。虽然不会经常使用引用语义，但他还是非常有用的。</p>
<div id="section-7.1" class="section level2">
<h2><span class="header-section-number">7.1</span> 环境基础</h2>
<p>环境的作用就是将一些名字与一些值进行关联，或者绑定(bind),可以把环境看做一个装满名字的口袋</p>
<p><img src="img/ch7-1.png" style="display: block; margin: auto;" /></p>
<p>每个名字都指向存储在内存中的一个对象</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">e &lt;-<span class="st"> </span><span class="kw">new.env</span>()
e<span class="op">$</span>a &lt;-<span class="st"> </span><span class="ot">FALSE</span>
e<span class="op">$</span>b &lt;-<span class="st"> &quot;a&quot;</span>
e<span class="op">$</span>c &lt;-<span class="st"> </span><span class="fl">2.3</span>
e<span class="op">$</span>d &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="dv">3</span></code></pre></div>
<p><img src="img/ch7-2.png" style="display: block; margin: auto;" /></p>
<p>对象并不生存在环境中，所以多个名字可指向同一个对象</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">e<span class="op">$</span>a &lt;-<span class="st"> </span>e<span class="op">$</span>d</code></pre></div>
<p><img src="img/ch7-3.png" style="display: block; margin: auto;" /></p>
<p>令人困惑的是，他们还可以指向具有相同值得不同对象</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">e<span class="op">$</span>a &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="dv">3</span></code></pre></div>
<p><img src="img/ch7-4.png" style="display: block; margin: auto;" /></p>
<p>如果对象没有指向它的名字，那么这个对象就会被垃圾回收器自动删除。</p>
<p>每个环境都有父环境，他是另外一个环境。在下图中，黑色小圆球代表指向父环境的指针，父环境用于实现词法作用域:如果一个名字在一个环境中没有找到，R就会到他的父环境去找（直到找到或遍历所有环境），只有空（empty）环境没有父环境</p>
<p><img src="img/ch7-5.png" style="display: block; margin: auto;" /></p>
<p>我们可以将环境之间的关系比作家庭中成员的关系。一个环境的爷爷就是他父亲的父亲，它的祖先就包括直到空环境的所有父环境。我们基本上不会说一个环境的子环境，因为他们之间没有反向链接，给定一个环境我们没有办法找到它的子环境。</p>
<p>通常环境与列表相似，除一下4点外：</p>
<ul>
<li><p>环境中的每个对象都有唯一的名字</p></li>
<li><p>环境中的对象没有顺序</p></li>
<li><p>环境有父环境</p></li>
<li><p>环境具有引用语义</p></li>
</ul>
<p>更专业一点，环境是有两部分构成：对象框，它包含名称-对象的绑定关系（行为商更像一个命名列表);它的父环境。</p>
<p>还有4个特殊的环境：</p>
<ul>
<li><p>globaenv()或者全局环境，他是一个交互式的工作环境，通常情况下我们就是在这个环境工作。全局环境的父环境就是libtary()或require()添加的最后一个包</p></li>
<li><p>baseenv(),基础环境，他是R基础软件包的环境，他的父环境是空环境</p></li>
<li><p>emptyenv(),空环境，他是所有环境的祖先，也是唯一一个没有父环境的环境</p></li>
<li><p>environment(),他是当前环境</p></li>
</ul>
<p>下面看一些环境方面的方法：</p>
<ul>
<li>search()</li>
</ul>
<p>列出全局环境的所有父环境</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">search</span>()</code></pre></div>
<pre><code>##  [1] &quot;.GlobalEnv&quot;        &quot;package:R6&quot;        &quot;package:pryr&quot;     
##  [4] &quot;package:stats&quot;     &quot;package:graphics&quot;  &quot;package:grDevices&quot;
##  [7] &quot;package:utils&quot;     &quot;package:datasets&quot;  &quot;package:methods&quot;  
## [10] &quot;Autoloads&quot;         &quot;package:base&quot;</code></pre>
<ul>
<li>as.environment()</li>
</ul>
<p>访问搜索列表中的任何环境</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">as.environment</span>(<span class="st">&quot;package:stats&quot;</span>)</code></pre></div>
<pre><code>## &lt;environment: package:stats&gt;
## attr(,&quot;name&quot;)
## [1] &quot;package:stats&quot;
## attr(,&quot;path&quot;)
## [1] &quot;D:/R-3.4.3/library/stats&quot;</code></pre>
<ul>
<li>new.env()</li>
</ul>
<p>手动创建一个环境，ls()可以列出将此环境的对象框中的所有绑定关系列出来，可以使用parent.env()查看他的父环境。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">e &lt;-<span class="st"> </span><span class="kw">new.env</span>()

<span class="kw">parent.env</span>(e)</code></pre></div>
<pre><code>## &lt;environment: R_GlobalEnv&gt;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ls</span>(e)</code></pre></div>
<pre><code>## character(0)</code></pre>
<p>对一个环境中的绑定关系进行修改的最简单的方法就是将其看做列表</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">e<span class="op">$</span>a &lt;-<span class="st"> </span><span class="dv">1</span>
e<span class="op">$</span>b &lt;-<span class="st"> </span><span class="dv">2</span>
<span class="kw">ls</span>(e)</code></pre></div>
<pre><code>## [1] &quot;a&quot; &quot;b&quot;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">e<span class="op">$</span>a</code></pre></div>
<pre><code>## [1] 1</code></pre>
<p>默认情况下，ls()只能列出不是一“.”开始的名字，可以通过设置参数all.names=TRUE来显示一个环境中的所有绑定关系：</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">e<span class="op">$</span>.a &lt;-<span class="st"> </span><span class="dv">2</span>
<span class="kw">ls</span>(e)</code></pre></div>
<pre><code>## [1] &quot;a&quot; &quot;b&quot;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ls</span>(e,<span class="dt">all.names=</span><span class="ot">TRUE</span>)</code></pre></div>
<pre><code>## [1] &quot;.a&quot; &quot;a&quot;  &quot;b&quot;</code></pre>
<ul>
<li>ls.str()</li>
</ul>
<p>它可以将环境中的所有对象都显示出来，比str()更有用</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str</span>(e)</code></pre></div>
<pre><code>## &lt;environment: 0x000000001b57e9e8&gt;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ls.str</span>(e)</code></pre></div>
<pre><code>## a :  num 1
## b :  num 2</code></pre>
<ul>
<li>获取绑定值</li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">e<span class="op">$</span>c &lt;-<span class="st"> </span><span class="dv">3</span>
e<span class="op">$</span>c</code></pre></div>
<pre><code>## [1] 3</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">e[[<span class="st">&quot;c&quot;</span>]]</code></pre></div>
<pre><code>## [1] 3</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">get</span>(<span class="st">&quot;c&quot;</span>,<span class="dt">envir=</span>e)</code></pre></div>
<pre><code>## [1] 3</code></pre>
<ul>
<li>从环境中删除对象</li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">e &lt;-<span class="st"> </span><span class="kw">new.env</span>()
e<span class="op">$</span>a &lt;-<span class="st"> </span><span class="dv">1</span>
e<span class="op">$</span>a &lt;-<span class="st"> </span><span class="ot">NULL</span> <span class="co">#这样相当于创建了一个新的对象</span>
<span class="kw">ls</span>(e)</code></pre></div>
<pre><code>## [1] &quot;a&quot;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">rm</span>(<span class="st">&quot;a&quot;</span>,<span class="dt">envir=</span>e)
<span class="kw">ls</span>(e)</code></pre></div>
<pre><code>## character(0)</code></pre>
<ul>
<li>exists()</li>
</ul>
<p>确定一个绑定是否存在</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="dv">10</span>
<span class="kw">exists</span>(<span class="st">&quot;x&quot;</span>,<span class="dt">envir=</span>e) <span class="co">#查找父环境</span></code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">exists</span>(<span class="st">&quot;x&quot;</span>,<span class="dt">envir=</span>e,<span class="dt">inherits=</span><span class="ot">FALSE</span>) <span class="co">#不希望在父环境中查找</span></code></pre></div>
<pre><code>## [1] FALSE</code></pre>
<ul>
<li>identical()</li>
</ul>
<p>identical()与==是不同的，是对两个环境进行比较</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">identical</span>(<span class="kw">globalenv</span>(),<span class="kw">environment</span>())</code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co">#globalenv()==environment()</span></code></pre></div>
</div>
<div id="section-7.2" class="section level2">
<h2><span class="header-section-number">7.2</span> 环境递归</h2>
<p>环境可以构成一棵树，因此我们非常方便的写出一个递归函数，pryr::where()会使用R的作用域法则找到定义这个名字的空间</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(pryr)
x &lt;-<span class="st"> </span><span class="dv">5</span>
<span class="co"># where函数由两个参数，一个是查找的名字(字符串)，一个是开始查找的环境</span>
<span class="kw">where</span>(<span class="st">&quot;x&quot;</span>)</code></pre></div>
<pre><code>## &lt;environment: R_GlobalEnv&gt;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">where &lt;-<span class="st"> </span><span class="cf">function</span>(name,<span class="dt">env=</span><span class="kw">parent.frame</span>()){
<span class="cf">if</span>(<span class="kw">identical</span>(env,<span class="kw">emptyenv</span>())){
  <span class="co"># Base case</span>
  <span class="kw">stop</span>(<span class="st">&quot;Can&#39;t find&quot;</span>,name,<span class="dt">call.=</span><span class="ot">FALSE</span>)
}<span class="cf">else</span> <span class="cf">if</span>(<span class="kw">exists</span>(name,<span class="dt">envir=</span>env,<span class="dt">inherits=</span><span class="ot">FALSE</span>)){
  <span class="co">#Success case</span>
  env
}<span class="cf">else</span>{
  <span class="co">#Recursive case</span>
  <span class="kw">where</span>(name,<span class="kw">parent.env</span>(env))
}
}</code></pre></div>
<p>有三种情况：</p>
<ul>
<li><p>基本情况： 已经到达空环境，但没有找到绑定，抛出一个错误</p></li>
<li><p>成功情况： 在这个环境中存在该对象，返回该环境</p></li>
<li><p>递归情况：在这个环境中没有找到该环境的对象，所以尝试在父环境中继续查找</p></li>
</ul>
</div>
<div id="section-7.3" class="section level2">
<h2><span class="header-section-number">7.3</span> 函数环境</h2>
<p>大对数环境并不是通过new.env()函数创建的，而是使用函数的结果，本节将讨论4种和函数相关的环境：封闭，绑定，执行和调用。</p>
<ul>
<li><p>封闭环境： 创建函数的环境，每个函数有且仅有一个封闭环境</p></li>
<li><p>使用&lt;-讲一个函数和一个名字进行绑定，就可以定义一个绑定环境</p></li>
<li><p>调用函数创建一个临时的执行环境，用来存储执行期间创建的各种变量</p></li>
<li><p>每个执行环境都与一个调用环境关联，他说明函数在哪调用</p></li>
</ul>
<div id="section-7.3.1" class="section level3">
<h3><span class="header-section-number">7.3.1</span> 封闭环境</h3>
<p>当创建一个函数，他就获得对创建他的函数的引用，这就是封闭环境，他用作此法作用域。为了确定一个函数的封闭空间，只需调用environment()并将函数名作为第一个参数</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">y &lt;-<span class="st"> </span><span class="dv">1</span>
f &lt;-<span class="st"> </span><span class="cf">function</span>(x) x<span class="op">+</span>y

<span class="kw">environment</span>(f)</code></pre></div>
<pre><code>## &lt;environment: R_GlobalEnv&gt;</code></pre>
<p>下图中，圆角矩形代表函数，黑色菱形代表一个函数的封闭环境</p>
<p><img src="img/ch7-6.png" style="display: block; margin: auto;" /></p>
</div>
<div id="section-7.3.2" class="section level3">
<h3><span class="header-section-number">7.3.2</span> 绑定环境</h3>
<p>上图太简单，因为函数没有名字，函数的名字可以通过绑定来定义，一个函数的绑定环境就是与其绑定的所有环境，下图更好的反映这种关系，因为封闭环境包含一个从f到环境的绑定</p>
<p><img src="img/ch7-7.png" style="display: block; margin: auto;" /></p>
<p>这种情况封闭环境和绑定环境是相同的，当将一个函数分配给另一个不同的环境，那么他们就同了</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">e &lt;-<span class="st"> </span><span class="kw">new.env</span>()
e<span class="op">$</span>g &lt;-<span class="st"> </span><span class="cf">function</span>() <span class="dv">1</span></code></pre></div>
<p><img src="img/ch7-8.png" style="display: block; margin: auto;" /></p>
<p>封闭函数属于该环境，永远也不会发生改变，甚至将该函数移动到其他环境中，封闭环境决定了这个函数该如何找到值，而绑定环境空间决定如何找到该函数。</p>
<p>绑定空间与封闭空间的区别在于软件包命名空间是非常重要的，例如如果软件包中A使用基础包中的mean()函数，那么如果软件包B也创建了自己的mean()函数会有什么后果呢？命名空间确保软件包A使用基础包中的mean(),而不受软件包B的影响（除非显式的调用）</p>
<p>命名空间使用环境来实现，利用函数不一定存在于他们的封闭环境中的事实，例如基础包中的sd()函数，它的封闭环境与绑定环境是不同的</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">environment</span>(sd)</code></pre></div>
<pre><code>## &lt;environment: namespace:stats&gt;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">where</span>(<span class="st">&quot;sd&quot;</span>)</code></pre></div>
<pre><code>## &lt;environment: package:stats&gt;
## attr(,&quot;name&quot;)
## [1] &quot;package:stats&quot;
## attr(,&quot;path&quot;)
## [1] &quot;D:/R-3.4.3/library/stats&quot;</code></pre>
<p>函数sd()的定义使用var()，但是如果创建自己的var()函数，那么他也不会影响sd()</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="dv">10</span>
<span class="kw">sd</span>(x)</code></pre></div>
<pre><code>## [1] 3.02765</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var &lt;-<span class="st"> </span><span class="cf">function</span>(x,<span class="dt">na.rm=</span><span class="ot">TRUE</span>) <span class="dv">100</span>

<span class="kw">sd</span>(x)</code></pre></div>
<pre><code>## [1] 3.02765</code></pre>
<p>这是可执行的，因为每个软件包有两个与他相关的环境：软件包环境和命名空间环境。软件包环境包含所有可以访问的公共函数，并且存放在搜索路径上，命名空间环境包含所有函数，并且它的父环境也是比较重要的环境，其中包含了这个软件包需要的所有函数的绑定。软件包中的每一个到处函数都绑定到软件包环境，但都在命名空间环境中，如下图展示杉树关系：</p>
<p><img src="img/ch7-9.png" style="display: block; margin: auto;" /></p>
<p>当输入var时，R首先会到全局环境中进行查找，当sd()查找var()时，他首先到命名空间中查找，而永远不会到globalenv()中查找。</p>
</div>
<div id="section-7.3.3" class="section level3">
<h3><span class="header-section-number">7.3.3</span> 执行环境</h3>
<p>第一次执行下面的函数他返回什么？，第二次呢？</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">g &lt;-<span class="st"> </span><span class="cf">function</span>(x) {
  <span class="cf">if</span>(<span class="op">!</span><span class="kw">exists</span>(<span class="st">&quot;a&quot;</span>,<span class="dt">inherits=</span><span class="ot">FALSE</span>)){
    <span class="kw">message</span>(<span class="st">&quot;Default a&quot;</span>)
    a &lt;-<span class="st"> </span><span class="dv">1</span>
  } <span class="cf">else</span> {
    a &lt;-<span class="st"> </span>a <span class="op">+</span><span class="st"> </span><span class="dv">1</span>
  }
  a
}

<span class="kw">g</span>(<span class="dv">10</span>)</code></pre></div>
<pre><code>## Default a</code></pre>
<pre><code>## [1] 1</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">g</span>(<span class="dv">10</span>)</code></pre></div>
<pre><code>## Default a</code></pre>
<pre><code>## [1] 1</code></pre>
<p>每次调用这个函数都返回相同的值，每次调用函数时都创建一个新的宿主执行环境，执行环境的父环境就是函数的封闭环境，一旦函数执行结束，这个环境就会被销毁。</p>
<p>通过图形简单了解这个过程：虚线包围的就是执行环境</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">h &lt;-<span class="st"> </span><span class="cf">function</span>(x) {
  a &lt;-<span class="st"> </span><span class="dv">2</span>
  x <span class="op">+</span><span class="st"> </span>a
}

y &lt;-<span class="st"> </span><span class="kw">h</span>(<span class="dv">1</span>)</code></pre></div>
<p>1.用 <span class="math inline">\(x=1\)</span> 调用函数</p>
<p><img src="img/ch7-10.png" style="display: block; margin: auto;" /></p>
<p>2.a被赋值为2</p>
<p><img src="img/ch7-11.png" style="display: block; margin: auto;" /></p>
<p>3.函数完成后返回值为3</p>
<p><img src="img/ch7-12.png" style="display: block; margin: auto;" /></p>
<p>当在另一个函数中创建一个函数的时候，子函数的封闭函数就是父函数的执行环境，而且执行环境也不再是临时的了。下面的栗子用一个函数工厂(相当于python闭包，装饰器)plus()来说明这个想法。我们使用这个工厂创建一个plus_one()函数，plus_one()的封闭环境是plus()的执行环境，其中x与数值1绑定</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">plus &lt;-<span class="st"> </span><span class="cf">function</span>(x){
  <span class="cf">function</span>(y) x<span class="op">+</span>y
  <span class="kw">message</span>(<span class="st">&quot;Note: &quot;</span>,<span class="st">&quot;plus_one also a function&quot;</span>)
  
}
plus_one &lt;-<span class="st"> </span><span class="kw">plus</span>(<span class="dv">1</span>)</code></pre></div>
<pre><code>## Note: plus_one also a function</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co">#注意plus_one也是一个函数</span></code></pre></div>
<p><img src="img/ch7-13.png" style="display: block; margin: auto;" /></p>
</div>
<div id="section-7.3.4" class="section level3">
<h3><span class="header-section-number">7.3.4</span> 调用环境</h3>
<p>查看下面代码。当代码运行时，你期望i()返回什么？</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">h &lt;-<span class="st"> </span><span class="cf">function</span>(){
  x &lt;-<span class="st"> </span><span class="dv">10</span>
  <span class="cf">function</span>(){
    def &lt;-<span class="st"> </span><span class="kw">get</span>(<span class="st">&quot;x&quot;</span>,<span class="kw">environment</span>())
    <span class="co">#返回函数被调用的环境</span>
    call &lt;-<span class="st"> </span><span class="kw">get</span>(<span class="st">&quot;x&quot;</span>,<span class="kw">parent.frame</span>())
    <span class="kw">list</span>(<span class="dt">defined=</span>def,<span class="dt">called=</span>call,<span class="dt">x=</span>x)
    <span class="co">#x</span>
  }
}

i &lt;-<span class="st"> </span><span class="kw">h</span>()
x &lt;-<span class="st"> </span><span class="dv">20</span>
<span class="kw">i</span>()</code></pre></div>
<pre><code>## $defined
## [1] 10
## 
## $called
## [1] 20
## 
## $x
## [1] 10</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co">#[1] 10</span></code></pre></div>
<p>最外层的x（绑定到20）是为了分散你的注意力：使用普通作用域法则，h()首先找到自己是在哪里定义的，然后再寻找与x相关联的值10，但是在调用i()的环境中与x相关的值是多少？在定义h()的环境中x为10，在调用h()的环境中x为20.</p>
<p>注意每个执行环境都有两个父环境：一个调用环境和一个封闭环境。R普通作用域法则只使用封闭的父环境，parent.frame()允许你访问调用父环境。在调用环境而不是封闭环境中查找变量称为动态作用域(注：很少的编程语言使用动态作用域，这是因为动态调用使我们更难理解函数式如何运行的，动态调用主要用于开发交互式数据分析的函数)</p>
</div>
</div>
<div id="section-7.4" class="section level2">
<h2><span class="header-section-number">7.4</span> 绑定名字和数值</h2>
<p>赋值操作其实就是就是将一个名字和一个值进行绑定，它对应于作用域，这个规则决定如何找到与一个名字相关联的值。可能你已经使用过上千次的R赋值语句，赋值操作为当前环境中的名称和对象建立一种绑定关系。名字通常包括字母，数字，.和_,但是不能以_开头，如果不遵守这些规则，则会出错。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">_abc &lt;-<span class="st"> </span><span class="dv">1</span>
<span class="co">#Error: unexpected input in &quot;_&quot;</span></code></pre></div>
<p>使用?Reserved可以获取完整的保留字列表，这些通常的规则也可以被重写。在一个由任何字符构成的名称的两遍加上反引号，就可以应用该名称了。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="st">`</span><span class="dt">a=b</span><span class="st">`</span> &lt;-<span class="st"> </span><span class="dv">3</span>
<span class="st">`</span><span class="dt">:)</span><span class="st">`</span> &lt;-<span class="st"> &quot;smile&quot;</span>
<span class="kw">ls</span>()</code></pre></div>
<pre><code>##  [1] &quot;:)&quot;                 &quot;a&quot;                  &quot;A&quot;                 
##  [4] &quot;a=b&quot;                &quot;Animal&quot;             &quot;area&quot;              
##  [7] &quot;b&quot;                  &quot;B&quot;                  &quot;b2&quot;                
## [10] &quot;Book&quot;               &quot;C&quot;                  &quot;c1&quot;                
## [13] &quot;c2&quot;                 &quot;cat&quot;                &quot;Cat&quot;               
## [16] &quot;cc&quot;                 &quot;cc2&quot;                &quot;circum&quot;            
## [19] &quot;conan&quot;              &quot;connan&quot;             &quot;Dog&quot;               
## [22] &quot;Duck&quot;               &quot;e&quot;                  &quot;e1&quot;                
## [25] &quot;e2&quot;                 &quot;f&quot;                  &quot;f1&quot;                
## [28] &quot;f1.character&quot;       &quot;f1.numeric&quot;         &quot;father&quot;            
## [31] &quot;g&quot;                  &quot;genderFactor&quot;       &quot;getShape&quot;          
## [34] &quot;h&quot;                  &quot;i&quot;                  &quot;j1&quot;                
## [37] &quot;Java&quot;               &quot;m1&quot;                 &quot;m2&quot;                
## [40] &quot;manager&quot;            &quot;member&quot;             &quot;Member&quot;            
## [43] &quot;mother&quot;             &quot;n1&quot;                 &quot;n2&quot;                
## [46] &quot;np6&quot;                &quot;NR6&quot;                &quot;p1&quot;                
## [49] &quot;Person&quot;             &quot;Php&quot;                &quot;plus&quot;              
## [52] &quot;plus_one&quot;           &quot;pr6&quot;                &quot;PR6&quot;               
## [55] &quot;R&quot;                  &quot;r1&quot;                 &quot;rc&quot;                
## [58] &quot;RC&quot;                 &quot;s&quot;                  &quot;s1&quot;                
## [61] &quot;son&quot;                &quot;student&quot;            &quot;student.attend&quot;    
## [64] &quot;student.default&quot;    &quot;student.exam&quot;       &quot;student.homework&quot;  
## [67] &quot;teacher&quot;            &quot;teacher.assignment&quot; &quot;teacher.correcting&quot;
## [70] &quot;teacher.default&quot;    &quot;teacher.lecture&quot;    &quot;u1&quot;                
## [73] &quot;u2&quot;                 &quot;u3&quot;                 &quot;User&quot;              
## [76] &quot;var&quot;                &quot;work&quot;               &quot;Worker&quot;            
## [79] &quot;x&quot;                  &quot;y&quot;</code></pre>
<p>除了使用反引号外，还可以使用单引号或双引号来创建非语法的绑定，但是不推荐这样做(在赋值箭头左边使用字符串属于历史问题，在R开始支持反引号之前就已经开始使用了)</p>
<p>普通的赋值箭头&lt;-总是在当前环境中创建一个变量。强制赋值箭头&lt;&lt;-不会再当前环境中创建变量，但是他修改父环境中已有的变量，也可以使用assign来进行深度绑定：name &lt;&lt;- value就等价于assign(“name”,value,inherits=TRUE)</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="dv">0</span>
f &lt;-<span class="st"> </span><span class="cf">function</span>(){
  x &lt;&lt;-<span class="st"> </span><span class="dv">1</span>
}

<span class="kw">f</span>()
x</code></pre></div>
<pre><code>## [1] 1</code></pre>
<p>还有另外两个绑定：延时绑定和主动绑定</p>
<ul>
<li>延时绑定：不是立即把结果赋给一个表达式，它创建和存储一个约定，在需要时对约定中的表达式进行求值，用特殊的赋值运算符号%&lt;d-%来创建延迟绑定,他是对delayedAssign()函数的封装，如果需要更多的控制可以使用该函数。</li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(pryr)
<span class="kw">system.time</span>(b <span class="op">%&lt;d-%</span><span class="st"> </span>{<span class="kw">Sys.sleep</span>(<span class="dv">1</span>); <span class="dv">1</span>})</code></pre></div>
<pre><code>##    user  system elapsed 
##       0       0       0</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">system.time</span>(b)</code></pre></div>
<pre><code>##    user  system elapsed 
##       0       0       1</code></pre>
<ul>
<li>主动绑定：不是绑定到常量对象，相反，每次对其进行访问时都要重新计算。%&lt;a-%是对基础函数makeActiveBinding()的封装。</li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x <span class="op">%&lt;a-%</span><span class="st"> </span><span class="kw">runif</span>(<span class="dv">1</span>)
x</code></pre></div>
<pre><code>## [1] 0.7978292</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x</code></pre></div>
<pre><code>## [1] 0.2967989</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">rm</span>(x)</code></pre></div>
</div>
<div id="section-7.5" class="section level2">
<h2><span class="header-section-number">7.5</span> 显式环境</h2>
<p>除了服务于作用域之外，环境也是一种很有用的数据结构，因此他们有引用语义，与R中的大多数对象不同，当你对环境进行修改时，R不会对其进行复制，例如：</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">modify &lt;-<span class="st"> </span><span class="cf">function</span>(x){
  x<span class="op">$</span>a &lt;-<span class="st"> </span><span class="dv">2</span>
  <span class="kw">invisible</span>()
}</code></pre></div>
<p>如果将这个函数应用于列表，原始列表不会被改变，因为修改列表实际上是创建和修改副本</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x_<span class="dv">1</span> &lt;-<span class="st"> </span><span class="kw">list</span>()

x_<span class="dv">1</span><span class="op">$</span>a &lt;-<span class="st"> </span><span class="dv">1</span>

<span class="kw">modify</span>(x_<span class="dv">1</span>)
x_<span class="dv">1</span><span class="op">$</span>a</code></pre></div>
<pre><code>## [1] 1</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co">#[1] 1</span></code></pre></div>
<p>但是如果将这个函数应用于环境，那么原始环境就会被修改</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x_e &lt;-<span class="st"> </span><span class="kw">new.env</span>()
x_e<span class="op">$</span>a &lt;-<span class="st"> </span><span class="dv">1</span>
<span class="kw">modify</span>(x_e)
x_e<span class="op">$</span>a</code></pre></div>
<pre><code>## [1] 2</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co">#[1] 2</span></code></pre></div>
<p>就像可以使用列表传递数据一样，也可以使用环境，当你创建自己的环境时，应该将父环境设置为空环境，这样确保不会从其他地方继承对象：</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="dv">1</span>

e1 &lt;-<span class="st"> </span><span class="kw">new.env</span>()

<span class="kw">get</span>(<span class="st">&quot;x&quot;</span>,<span class="dt">envir=</span>e1)</code></pre></div>
<pre><code>## [1] 1</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># e2 &lt;- new.env(parent=emptyenv())</span>
<span class="co"># get(&quot;x&quot;,envir = e2)</span>

<span class="co">#Error in get(&quot;x&quot;, envir = e2) : object &#39;x&#39; not found</span></code></pre></div>
<p>环境时解决下面3类常见问题的有效数据结构</p>
<ul>
<li><p>避免大数据的复制</p></li>
<li><p>管理一个软件包的内部状态</p></li>
<li><p>根据名字高效的查找与其绑定的值</p></li>
</ul>
<div id="section-7.5.1" class="section level3">
<h3><span class="header-section-number">7.5.1</span> 避免复制</h3>
<p>由于环境具有引用语义，所有绝不会无意识的创建一个副本。Biocinductor包中经常使用这种技术，因为它经常需要对非常大的基因对象进行管理。在R3.1.0版本后，这种技术已经不像以前那么重要了，因为修改列表不再是深度复制了。以前修改列表的一个元素也要复制整个列表，如果有些元素非常大，就会造成昂贵的操作。</p>
</div>
<div id="section-7.5.2" class="section level3">
<h3><span class="header-section-number">7.5.2</span> 软件包状态</h3>
<p>显式环境在软件包中很有用，因为他们允许你在函数调用之间保持软件包的状态，正常情况下软件包的对象是被锁定的，所以你不能直接修改他们，但是可以这样做：</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">my_env &lt;-<span class="st"> </span><span class="kw">new.env</span>(<span class="dt">parent =</span> <span class="kw">emptyenv</span>())
my_env<span class="op">$</span>a &lt;-<span class="st"> </span><span class="dv">1</span>

get_a &lt;-<span class="st"> </span><span class="cf">function</span>(){
  my_env<span class="op">$</span>a
}

set_a &lt;-<span class="st"> </span><span class="cf">function</span>(value){
  old &lt;-<span class="st"> </span>my_env<span class="op">$</span>a
  my_env<span class="op">$</span>a &lt;-<span class="st"> </span>value
  <span class="kw">invisible</span>(old) <span class="co">#不返回old</span>
}</code></pre></div>
</div>
<div id="hashmap" class="section level3">
<h3><span class="header-section-number">7.5.3</span> 模拟hashmap</h3>
<p>hashmap是一种非常有用的数据结构，它根据名字查找对象的时间复杂度为O(1)。环境默认提供这种行为，所以可以用它来模拟hashmap。CRAN的hash包就是用这种思想开发的</p>
</div>
</div>
<div id="section-7.6" class="section level2">
<h2><span class="header-section-number">7.6</span> 总结</h2>
<p>截止到这，我们的R语言面型对象的内容介绍完了，回顾起来，首先我们介绍了R语言编程的一些规范，告诉读者要参考一些标准的规范构建自己的编程规范并在团队中做出调整，增加自己代码的可读性和运行效率，紧接着我们分了5章系统全面的介绍了R语言的面向对象编程:S3,S4,R5,R6;最后本章我们介绍了R语言环境的相关知识，环境不仅是作用域的描述，更是一种非常好用的数据结构。</p>
<p>最后希望阅读本电子书的R语言用户,阅读完本书后对你有一点点的帮助。</p>

</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="R6.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="Reference.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"google": false,
"linkedin": false,
"weibo": false,
"instapper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"download": ["R_OOP.pdf", "R_OOP.epub"],
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "";
    if (src === "" || src === "true") src = "https://cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:" && /^https?:/.test(src))
      src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
